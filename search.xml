<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css3单位]]></title>
    <url>%2F2019%2F03%2F10%2Fcss3%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[背景介绍统的项目开发中，我们只会用到px、%、em这几个单位，它可以适用于大部分的项目开发，并且拥有比较良好的兼容性。但是你知道吗？从css3开始，浏览器对逻辑单位的支持又提升到了另外一个境界，增加了rem、vh、vw、vm等一些新的长度单位，我们可以利用这些新的单位开发出比较良好的响应式页面，随之覆盖多种不同分辨率的终端，包括移动设备等。现在让我们来看下这些长度单位有什么区别。 知识剖析pxpx就是pixel的缩写，意为像素。px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的，比如常常听到的电脑像素是1024x768的，表示的是水平方向是1024个像素点，垂直方向是768个像素点（设备像素），css中的像素px是一个相对单位，要考虑它的上下文； em参考物是父元素的font-size，具有继承的特点。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。 remcss3新单位，相对于根元素html（网页）的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱 %一般宽泛的讲是相对于父元素，但是并不是十分准确。(1) 对于普通定位元素就是我们理解的父元素(2) 对于position: absolute;的元素是相对于已定位的父元素(3) 对于position: fixed;的元素是相对于 ViewPort（可视窗口）(4) 子元素padding-top || padding-bottom 设置%，相对于父级的宽度进行定位 vwcss3新单位，viewpoint width的缩写，视窗宽度，1vw等于视窗宽度的1%举个例子：浏览器宽度1200px, 1 vw = 1200px/100 = 12 px。 vhcss3新单位，viewpoint height的缩写，视窗高度，1vh等于视窗高度的1%举个例子：浏览器高度900px, 1 vh = 900px/100 = 9 px。 vmcss3新单位，相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vm高度小，将高度分为100份，20vm,取20份举个例子：浏览器高度900px，宽度1200px，取最小的浏览器高度， 1 vm = 900px/100 = 9 px。 常见问题为什么一开始在css样式中给body设置font-size：62.5%？Font-size=62.5%这就使em值变为16px*62.5%=10px。这样1em=10px，1.2em=12px利于我们进行换算。]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>rem vw vh vm em px</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[viewport]]></title>
    <url>%2F2019%2F03%2F10%2Fviewport%2F</url>
    <content type="text"><![CDATA[viewportPPK的关于三个viewport的理论:ppk大神对于移动设备上的viewport有着非常多的研究（第一篇，第二篇，第三篇），有兴趣的同学可以去看一下，本文中有很多数据和观点也是出自那里。ppk认为，移动设备上有三个viewport。 首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就越多，devicePixelRatio的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做 layout viewport。 这个layout viewport的宽度可以通过document.documentElement.clientWidth 来获取。 然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，ppk把这个viewport叫做 visual viewport 。visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。在我们已经有两个viewport了：layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。ppk把这个viewport叫做 ideal viewport，也就是第三个viewport——移动设备的理想viewport。 ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。 再总结一下：ppk把移动设备上的viewport分为 layout viewport 、 visual viewport 和 ideal viewport 三类，其中的ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。 利用meta标签对viewport进行控制移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。 我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。 这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？ meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。 在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素特别说明的是，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。因为这个属性只有安卓支持，并且安卓已经决定要废弃target-densitydpi 这个属性了，所以这个属性我们要避免进行使用 。 把当前的viewport宽度设置为 ideal viewport 的宽度要得到ideal viewport就必须把默认的layout viewport的宽度设为移动设备的屏幕宽度。因为meta viewport中的width能控制layout viewport的宽度，所以我们只需要把width设为width-device这个特殊的值就行了。 下图是这句代码在各大移动端浏览器上的测试结果： 可以看到通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。 这样的写法看起来谁都会做，没吃过猪肉，谁还没见过猪跑啊~，确实，我们在开发移动设备上的网页时，不管你明不明白什么是viewport，可能你只需要这么一句代码就够了。 可是你肯定不知道 1&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt; 这句代码也能达到和前一句代码一样的效果，也可以把当前的的viewport变为 ideal viewport。 呵呵，傻眼了吧，因为从理论上来讲，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大。那为什么会有 width=device-width 的效果呢？ 要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport 吗？事实证明，的确是这样的。下图是各大移动端的浏览器当设置了content=”initial-scale=1”后是否能把当前的viewport 宽度变成 ideal viewport 的宽度的测试结果: 测试结果表明 initial-scale=1 也能把当前的 viewport 宽度变成 ideal viewport 的宽度，但这次轮到了windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时 ideal viewport 的宽度。但这点小瑕疵已经无关紧要了。 但如果 width 和 initial-scale=1 同时出现，并且还出现了冲突呢？比如：1&lt;meta name=&quot;viewport&quot; content=&quot;width=400, initial-scale=1&quot;&gt; width=400 表示把当前 viewport 的宽度设为400px，initial-scale=1 则表示把当前 viewport 的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport 的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度） 最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 关于缩放以及initial-scale的默认值先我们先来讨论一下缩放的问题，前面已经提到过，缩放是相对于 ideal viewport 缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport 的宽度是320px，如果我们设置 initial-scale=2 ，此时 viewport 的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此，我们可以得出一个公式：12visual viewport宽度 = ideal viewport宽度 / 当前缩放值当前缩放值 = ideal viewport宽度 / visual viewport宽度 ps: visual viewport 的宽度指的是浏览器可视区域的宽度。 大多数浏览器都符合这个理论，但是安卓上的原生浏览器以及IE有些问题。安卓自带的webkit浏览器只有在 initial-scale = 1 以及没有设置width属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，initial-scale表现出来的效果永远是1。 好了，现在再来说下 initial-scale 的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 initial-scale = 1 时，当前的 layout viewport 宽度会被设为 ideal viewport 的宽度，但前面说了，各浏览器默认的 layout viewport 宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport 的宽度的，所以 initial-scale 的默认值肯定不是1。安卓设备上的 initial-scale 默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用，我们不管它了，这里我们重点说一下iphone和ipad上的 initial-scale 默认值。 根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给 layout viewpor 设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算 initial-scale 这个值，以保证当前 layout viewport 的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。比如说，在iphone上，我们不设置任何的 viewport meta 标签，此时 layout viewport 的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了。根据上面的公式，当前缩放值 = ideal viewport宽度 / visual viewport宽度，我们可以得出：当前缩放值 = 320 / 980就是当前的 initial-scale 默认值应该是 0.33这样子。当你指定了 initial-scale 的值后，这个默认值就不起作用了。总之记住这个结论就行了：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。 动态改变viewport标签123456789101112131415161718192021第一种方法可以使用 document.write 来动态输出 meta viewport 标签，例如：document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&apos;)第二种方法通过 setAttribute 来改变&lt;meta id=&quot;testViewport&quot; name=&quot;viewport&quot; content=&quot;width = 380&quot;&gt;&lt;script&gt;var mvp = document.getElementById(&apos;testViewport&apos;);mvp.setAttribute(&apos;content&apos;,&apos;width=480&apos;);&lt;/script&gt;安卓2.3自带浏览器上的一个 bug&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;alert(document.documentElement.clientWidth); //弹出600，正常情况应该弹出320&lt;/script&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=600&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;alert(document.documentElement.clientWidth); //弹出320，正常情况应该弹出600&lt;/script&gt; 测试的手机 ideal viewport 宽度为320px，第一次弹出的值是600,但这个值应该是第行meta标签的结果啊，然后第二次弹出的值是320，这才是第一行meta标签所达到的效果啊，所以在安卓2.3(或许是所有2.x版本中)的自带浏览器中，对 meta viewport 标签进行覆盖或更改，会出现让人非常迷糊的结果。 举个例子一只笔的像素如下：这只笔在屏幕c,d,e下的显示效果如下到同一张图片在各屏幕显示大小不一。我们希望不同屏幕显示图片的大小要一致。我们要计算图片缩放比例。计算公式：(图片逻辑像素大小px1) / (图片缩放后实际像素大小px2) = (设备像素dp) / (设备独立像素dips)px2 = px1 (dp / dips)px2 = px1 dpr此时，这只笔在屏幕c,d,e下的显示效果如下：通过上面的我们可以看到，不同的 DPR (设备像素比)要想显示大小一样，必须准备三张不同分辨率的图片，那么，我想一张图片就在三种不同的屏幕下显示一样的大小，能做到吗？当然能做到，这就需要缩放了，要自己计算缩放多麻烦，那有没有一种简单的方式呢？当然有，那就是你在熟悉不过的px,你会发现设置图片宽度为50px以后，在各个移动终端的大小看起来都一样，这是什么原因呢。照 CSS 规范的定义，CSS 中的 px 是一个相对长度，它相对的，是 viewing device 的分辨率。这个viewing device，通常就是电脑显示器。典型的电脑显示器的分辨率是96DPI，也就是1像素为1/96英寸（实际上，假设我们的显示器分辨率都与物理分辨率一致，而液晶点距其实是0.25mm到0.29mm之间，所以不太可能是正好1/96英寸，而只是接近）。一般来说，px 就是对应设备的物理像素，然而如果输出设备的解析度与电脑显示器大不相同，输出效果就会有问题。例如打印机输出到纸张上，其解析度比电脑屏幕要高许多，如果不缩放，直接使用设备的物理像素，那电脑上的照片由 600DPI 的打印机打出来就比用显示器看小了约6倍。 所以 CSS 规定，在这种情况下，浏览器应该对像素值进行缩放调节，以保持阅读体验的大体一致。也就是要保持一定像素的长度在不同设备输出上看上去的大小总是差不多。 怎样确保这一点呢？直接按照设备物理像素的大小进行换算当然是一个方式，但是CSS考虑得更多，它建议，转换应按照“参考像素”（reference pixel）来进行。 眼睛看到的大小，取决于可视角度。而可视角度取决于物体的实际大小以及物体与眼睛的距离。10米远处一个1米见方的东西，与1米远处的10厘米见方的东西，看上去的大小差不多是一样的，所谓一叶障目不见泰山，讲的就是这个常识。 因此CSS规范使用视角来定义“参考像素”，1参考像素即为从一臂之遥看解析度为96DPI的设备输出（即1英寸96点）时，1点（即1/96英寸）的视角。 请注意这个差别——CSS规范定义的参考像素并不是1/96英寸，而是1/96英寸在一臂之遥的看起来的视角。通常认为常人臂长为28英寸，所以其视角可以计算出来是0.0213度。（即(1/96)in / (28in 2 PI / 360deg) ） 我们在使用不同设备输出时，眼睛与设备输出的典型距离是不同的。比如电脑显示器，通常是一臂之距，而看书和纸张时（对应于打印机的设备输出），则通常会更近一些。看电视时则会更远，比如一般建议是电视机屏幕对角线的2.5到3倍长——如果你是个42’彩电，那就差不多是3米远。看电影的话……我就不知道多远了，您自己量吧。因此，1参考像素：对于电脑显示器是0.26mm（即1/96英寸）；对于激光打印机是0.20mm（假设阅读距离通常为55cm，即21英寸）； 而换算时，对于300DPI的打印机（即每个点是1/300英寸），1px通常会四舍五入到3dots，也就是0.25mm左右；而对于600DPI的打印机，则可能四舍五入到5dots，也就是0.21mm。上图中，左边的屏幕（可以认为是电脑屏幕）的典型视觉距离是71厘米即28英寸，其1px对应了0.28mm；而右边的屏幕（可以认为是你的42寸高清电视）的典型视觉距离是3.5米即120英寸，其1px对应1.3mm。42寸的1080p电视，分辨率是1920*1080，则其物理像素只有0.5mm左右，可见确实是高清哦。 综上，px 是一个相对单位，而且在特定设备上总是一个近似值（原则是尽量接近参考像素）。 然而，如果你把绝对单位理解为对输出效果的绝对掌控，事情却大相径庭。就网页输出的最主要对象——电脑屏幕来说，px 可被视为一个基准单位——与桌面分辨率一致，如果是液晶屏，则几乎总是与液晶屏物理分辨率一致——也就是说网页设计者设定的1px，就是“最终看到这个网页的用户的显示器上的1个点距”！反倒是那些绝对单位，其实一点也不绝对参考：https://www.quirksmode.org/mobilewebhandbook/chapter1.html https://www.cnblogs.com/zaoa/p/8630393.html]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>viewport</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css像素问题]]></title>
    <url>%2F2019%2F03%2F10%2Fcss%E5%83%8F%E7%B4%A0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[px(css pixels)什么是pxpx虚拟像素, 游览器内的一切长度是以css像素为单位的；CSS像素的单位是px 注意（1）在css规范中，长度单位分为两类，相对单位（relative）和绝对单位（absolute）,px是一个相对单位，相对的是设备像素（device pixel）（2）在同一个设备中，每一个css像素所代表的物理像素是可变的（css像素第一方面的相对性）（3）在不同设备之间，每一个css像素所代表的物理像素也是可变的（css像素第二方面的相对性） 例子作为Web开发者，我们接触的更多的是用于控制元素样式的样式单位像素。这里的像素我们称之为CSS像素；假设我们用pc游览器打开一个宽为800的页面，页面上有一个宽度为400px的块级容器，很明显这个块级容器应该占页面的一半，我们把页面放大，放大为200%；你会发现，这个块级容器占满整个游览器，吊诡的是此时我们既没有调整浏览器窗口大小，也没有改变块状元素的css宽度，但是它看上去却变大了一倍——这是因为我们把CSS像素放大为了原来的两倍；CSS像素与屏幕像素1：1同样大小时： CSS像素(黑色边框)开始被拉伸，此时1个CSS像素大于1个屏幕像素 也就是说默认情况下一个CSS像素应该是等于一个物理像素的宽度的，但是浏览器的放大操作让一个CSS像素等于了2个设备像素宽度。在后面你会看到更复杂的情况，在高PPI的设备上，CSS像素甚至在默认状态下就相当于多个物理像素的尺寸。从上面的例子可以看出，CSS像素从来都只是一个相对值。 DP(device pixels)设备像素定义设备像素（物理像素），顾名思义，显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，单位pt。 注意pt在css单位中属于真正的绝对单位，1pt = 1/72(inch),inch及英寸，而1英寸等于2.54厘米。 不同的设备，其图像基本单位是不同的，比如显示器的点距，可以认为是显示器的物理像素。现在的液晶显示器的点距一般在0.25mm到0.29mm之间。而打印机的墨点，也可以认为是打印机的物理像素，300DPI就是0.085mm，600DPI就是0.042mm。 注意，我们通常所说的显示器分辨率，其实是指桌面设定的分辨率，而不是显示器的物理分辨率。只不过现在液晶显示器成为主流，由于液晶的显示原理与CRT不同，只有在桌面分辨率与物理分辨率一致的情况下，显示效果最佳，所以现在我们的桌面分辨率几乎总是与显示器的物理分辨率一致了。 DPR(device pixels ratio)设备像素比定义设备像素比（dpr 描述的是未缩放状态下，物理像素和CSS像素的初始比例关系，计算方法如下图 理解设备像素比(dpr) 是指在移动开发中1个css像素占用多少设备像素，如2代表1个css像素用2x2个设备像素来绘制。设备像素比(dpr)，可以理解为1px由多少个设备像素组成； 设备像素与css像素之间的关系获得设备像素比DPR（device pixels ratio）后，便可得知设备像素与CSS像素之间的比例。当这个比率为1:1时，使用1个设备像素显示1个CSS像素。当这个比率为2:1时，使用4个设备像素显示1个CSS像素，当这个比率为3:1时，使用9（3*3）个设备像素显示1个CSS像素。 DIP(Device independent Pixel)设备独立像素设备独立像素，也称为逻辑像素，简称dip。根据上述设备像素与CSS像素之间的关系、及DPR的官方定义，我们可以推断出：CSS像素 =设备独立像素 = 逻辑像素在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。CSS像素就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2 个物理像素;为什么是“每四个一组”？而且要让这四个一组来显示“原来屏幕的一个像素”？这大概就是 Retina 显示技术的一种表现吧。而这“每四个一组”的“大像素”，可以被称作“设备独立像素”，device independent pixel ，或者 density-independentpixel ，它可以是系统中的一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统转换为物理像素。 “设备独立像素”也有人称为“CSS像素”，一种形象的说法，更倾向于表明与 CSS 中尺寸的对应; PPI(pixels per inch)定义每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。 ppi是如何计算出来的呢？顾名思义，每英寸的像素点（设备像素），已知屏幕分辨率和主对角线的尺寸，则ppi等于以爱疯6为例我们知道，ppi越高，每英寸像素点越多，图像越清晰；我们可以类比物体的密度，密度越大，单位体积的质量就越大，ppi越高，单位面积的像素越多。 ppi和dpr到底什么关系？毕竟这些参数是外国人先发明的，他们会优先选择自己熟悉的计量单位作为显示设备的工厂标准参数，因此ppi就用作显示设备的工业标准；告诉业界人士，ppi达到多少是高清屏，此时对应的dpr是多少，而不直接告诉你我现在的显示设备dpr是多少，毕竟人们直接听到像素分辨率会更加有反应。设备像素比与ppi相关，一般是ppi/160的整数倍： 倍率与逻辑像素Retina显示屏这是一种显示技术，可以将把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度，这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。两代iPhone 的物理尺寸（屏幕宽高有多少英寸）是一样的，从上图可以看出，iphone 4的显示效果要明显好于iphone 3GS，虽然 iPhone 4 分辨率提高了，但它不同于普通的电脑显示器那样为了显示更多的内容，而是提升显示相同内容时的画面精细程度。这种提升方式是靠提升单位面积屏幕的像素数量，即像素密度来提升分辨率，这样做的主要目的是为了提高屏幕显示画面的精细程度。以第三代 MacBook Pro with Retina Display为例， 工作时显卡渲染出的2880x1880个像素每四个一组，输出原来屏幕的一个像素显示的大小区域内的图像。这样一来，用户所看到的图标与文字的大小与原来的1440x900分辨率显示屏相同，但精细度是原来的4倍。 注意：在桌面显示器中，我们调整了显示分辨率，比如从 800 600 调整到 1024 768 时，屏幕的文字图标会变小，显示的内容更多了。但 Retina 显示方式不会产生这样的问题，或者说， Retina 显示技术解决的是显示画面精细程度的问题，而不是解决显示内容容量的问题。苹果以普通屏为基准，给Retina屏定义了一个2倍的倍率（iPhone 6plus除外，它达到了3倍）。实际像素除以倍率，就得到逻辑像素尺寸。只要两个屏幕逻辑像素相同，它们的显示效果就是相同的。我们以 7 plus 为例抽取如下几个关键词（这些关键词跟我们今天要说的内容都息息相关）： Retina HD 显示屏 5.5 英寸 1920 x 1080 像素分辨率 401 ppi 5.5英寸这个比较简单，就是显示屏对角线的长度（我们可以通过勾股定理计算得到，甚至可以自己用尺子去量）。如下几种不同的 iPhone 的几种尺寸规格 注：1英寸（inch）=2.54厘米（cm）1920 x 1080 像素分辨率表示该显示屏的分辨率为：1920px x 1080px。 前面我们已经说过，显示屏上的每个图形都是由一个一个像素点构成的，下面的图形可以很形象的帮助你明白；既然明白了像素点，现在我们就可以解释分辨率1920px x 1080px的意思了。它表示在这个iPhone 7 plus 5.5 英寸英寸屏幕上，在竖向的高度上有1920个像素点，在横向的宽度上有1080个像素点。我们把分辨率的像素称之为物理像素或设备像素（如 iPhone 7 的物理像素为 750px 1334px），它是显示设备中一个最微小的物理部件。设备独立像素：CSS 的尺寸像素称之为设备独立像素（device-independent pixels 简称为“DIPs”）或 CSS 像素（如 iPhone 7 的设备独立像素为 375px 667px），它是一个抽象的单位，主要使用在浏览器上，用来精确的度量（确定）Web页面上的内容。devicePixelRatio（简写 DPR）： 用来描述物理像素与设备独立像素的比例，其值等于 “物理像素 / 设备独立像素”。devicePixelRatio 值为 1 时就是我们的标准屏，值为 2 时则是我们俗称的 2 倍屏（2x），同样 3 就是 3 倍屏（3x）通过上面的说明，我们可以得到 iPhone 7 的 devicePixelRatio 为 2 （750px / 375px = 2），就是 2 倍屏。那么这个 2 倍屏跟我们普通的标准屏有什么区别呢？对一个标准屏来说，渲染一个 2px 2px 的盒子将会使用 2px 2px 物理像素，如我们的普通电脑屏；但是对于一个 2 倍屏来说，渲染一个 2px 2px 的盒子将会使用 （2px 2） （2px 2） 物理像素，如我们的 iPhone 4、5、6、7，如下图： 基本关系用iPhone 3gs和4s来举例。假设有个邮件列表界面，我们不妨按照PC端网页设计的思维来想象。3gs上大概只能显示4-5行，4s就能显示9-10行，而且每行会变得特别宽。但两款手机其实是一样大的。如果照这种方式显示，3gs上刚刚好的效果，在4s上就会小到根本看不清字。在现实中，这两者效果却是一样的。这是因为Retina屏幕把2x2个像素当1个像素使用。比如原本44像素高的顶部导航栏，在Retina屏上用了88个像素的高度来显示。导致界面元素都变成2倍大小，反而和3gs效果一样了。画质却更清晰。 面临问题熟悉了这些概念之后，我们就要开始解决需要面临的问题了。由于 devicePixelRatio 不再是1，我们的物理像素与设备独立像素不再对等，所以在实际网页开发时面临了2个问题：图片虚化、1px边框变粗 图片虚化我们知道，位图（png, jpg, gif等）是由一个个像素点构成的，每个像素都具有特定的位置和颜色值，我们称之为位图像素，如下图：当一个位图在标准屏显示时，一位图像素对应的就是一物理像素，这样就保证了一个完全保真的显示。但是当在 2 倍屏下时，它需要要放大四倍（宽高各两倍）来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形，也就是我们常说的图片虚化问题。如下图：那么怎么解决该问题呢？说到底就是为了让一位图像素对应一物理像素，既然物理像素已经定了不能变，那么我们是否可以改变位图像素呢？答案是肯定的。我们可以把要使用的图片扩大一倍，如要用的图片大小为 2px 2px，我们可以使用 4px 4px 的图片然后设置图片大小为 2px * 2px，这样对于2倍屏则正好，而标准屏则减少像素取样（一定程度上的浪费），如下图：这样就解决了我们的图片在2倍屏的虚化问题，对于3倍屏也是一样的道理 跟多相关知识见：viewport 参考：https://www.quirksmode.org/mobilewebhandbook/chapter1.html https://www.cnblogs.com/zaoa/p/8630393.html]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>px 物理像素 逻辑像素 设备像素比 ppi viewport</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步加载js文件]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>WebWorker async defer webService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[游览器结构]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%B8%B8%E8%A7%88%E5%99%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack打包原理]]></title>
    <url>%2F2019%2F02%2F26%2Fwebpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端模块化]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端模块化什么是前端模块化？模块化在任何开发中都是必不可少，但是早起前端没有强烈模块化的概念，随着web技术不断的发展，前端逻辑越来越复杂，如果没有一种模块化机制来管理一些文件的话，会使程序很复杂；前端的模块化是Node.js带来的新产物，后端开发没有模块化不能进行，随着Node.js的出现，JavaScript开始在后端发挥作用，为了代码重用，模块化变得不可或缺； 模块化的优点 避免变量污染，命名冲突 提高代码复用率 提高维护性（代码逻辑层次分明） 依赖关系的管理早期前端模块化 命名空间模式 声明依赖关系 私有和特权成员 私有变量（立即执行函数）命名空间模式解决的问题：有助于减少程序中所需要的全局变量的数量，并且还有助于避免命名冲突。缺点：（1）需要输入更多的字符，每个变量和函数前都需要增加前缀，总体上需要增加下载的代码量；（2）仅有一个全局对象意味着任何部分代码都可以修改该全局对象，并且可以获得更新后的状态（以预期之想改一个地方，另一个地方不变不符）（3）长嵌套的名字意味着更长的属性解析时间； javascript没有内置的内存空间，但是这种特征是非常容易实现的，可以为你的库创建一个全局对象，然后将你的所有功能添加到该全局对象里面，从而在具有大量的函数，对象和其他变量的情况下并不会污染全局变量。1234567891011121314var a = 3;var d = 4;function f() &#123;&#125;var module1 = &#123;a: 1, b: 2&#125;// 上面一共有4个全局变量// 可以通过为应用程序创建一个全局对象来重构上面的这些代码// 之后变为1个全局变量var MYAPP = &#123;&#125;; // 全局变量MYAPP.a = 3;MYAPP.b = 4;MYAPP.f = function() &#123;&#125;;MYAPP.module1 = &#123;a: 1, b: 2&#125; 通用命名空间 由于程序的复杂性增加，代码的某些部分被分割成不同的文件，这种情况下，假设你的代码是第一个定义某个命名空间内部的一个属性，这种做法已经不安全了。添加到命名空间的一些属性方法可能已经存在了，这会导致覆盖他们，因此在添加一个属性或者创建一个命名空间之前，最好先检查他是否存在； 12345678// 不安全的代码var MYAPP = &#123;&#125;;// 更好的代码分格if(typeof MYAPP === &apos;undefined&apos;) &#123; var MYAPP = &#123;&#125;;&#125;// 或者更短的语句var MYAPP = MYAPP || &#123;&#125;; 重复的检查增加了大量重复的代码，如果想定义MYAPP.modlules.module2,必须构造三次检查，每次检查都要针对定义的对象或者属性，我们通过namespace函数处理这些操作。 12345678910111213141516var MYAPP = MYAPP || &#123;&#125;;MYAPP.namespace = function (ns_string) &#123; var parts = ns_string.split(&apos;.&apos;), parent = MYAPP, i; if (parts[0] === &quot;MYAPP&quot;) &#123; parts = parts.slice(1); &#125; for (i = 0;i &lt; parts.length; i++) &#123; if (typeof parent[parts[i]] === &apos;undefined&apos;) &#123; parent[parts[i]] = &#123;&#125;; &#125; parent = parent[parts[i]]; &#125; return parent;&#125; 声明依赖关系在你的函数或者模块的顶部， 声明代码所依赖的模块是一个非常好的注意，改声明仅涉及及创建一个局部变量并使其指向所需模块；当用jquery获取dom时候，在模块顶部声明局部变量将dom付给局部变量； 123456function c () &#123; var oDom = $(&apos;div&apos;); // 多次使用dom变量&#125;c(); 这是既简单的模式，但是他有很多优点：（1）显示的依赖声明想你的代码和用户表明他所需要的脚本文件，已经包含在改页面中了。（2）javascript引擎，解析局部变量的速度总是要比解析全局变量和嵌套属性要快，导致了更好的性能。当使用这种声明模式的时候，全局符号解析仅在函数中执行一次，再此之后将会使用局部变量，这种解析快很多； 私有属性和方法javascript 没有特殊语法来表示私有，所有对象的属性都是公有的, 公有的概念是可访问，和修盖的属性例如：1234567891011121314var myobj = &#123; myprop: 1&#125;console.log(myobj.myprop); // 1 是公有的可访问的function Ga() &#123; this.name = &apos;ipod&apos;; this.stretch = function () &#123; return &apos;ipod&apos;; &#125;&#125;var toy = new Ga();console.log(toy.name); // &apos;name&apos; 是公有的console.log(toy.stretch()); // stretch()是公有的 通过一些手段可以让对象或者构造函数获得私有性私有成员： 虽然javascript语言中没有私有成员，但是有私有变量，任何在函数中定义的变量为私有变量（私有成员）特权方法： 指可以访问私有成员的公共方法 123456789101112function Gadget() &#123; // 私有成员 var name = &apos;ipod&apos;; // 公有函数 也叫特权方法 this.getName = function () &#123; return name; &#125;&#125;var toy = new Gadget();console.log(toy.name); // 访问不到name 是私有变量// 公有方法访问私有属性console.log(toy.getName()); // 输出’ipod‘ 对象字面量以及私有性 正如前面所言，需要一个能够包装数据的函数，因此在使用对象字面量的情况下，可以使用一个匿名函数创建闭包，来实现字面量的私有性； 12345678910111213var myobj = (function() &#123; // 私有成员 var name = 'my best teach'; // 实现公有部分 return &#123; // 特权方法 getName()&#123; return name; &#125; &#125;&#125;)();myobj.getName(); // 输出'my best teach' 这个例子称为“模块模式的基本框架” 模块模式模块模式就是以下模式组合:（1）命名空间（2）立即执行函数（3）私有和特权成员（4）声明依赖 从CommonJS到ES6模块化开发的优点： 定义：把一个复杂的系统分解为一个一个模块。（1）代码复用，让我们更方便的进行代码管理，同时也便于后期代码的修改与维护（2）一个单独的文件就是一个作用域，只向外面暴露特定的函数与变量，避免全局变量污染，减少变量命名冲突； js模块化规范有：CommonJS, AMD, CMD; CommonJS 规范是服务器端模块的规范，由node.js推广使用，该规范的核心思想是；允许模块通过require方法来同步加载所需要的依赖的其他模块；然后通过exports, 和module.exports来导出需要暴露的接口；CommonJS 特点(1) 所有代码都运行在模块作用域，不会污染全局作用域。(2) 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。(3) 模块加载的顺序，按照其在代码中出现的顺序。 module每个模块内部，都有一个module对象代表当前模块，他有以下属性index.js1console.log(module); 12345678910111213141516171819202122232425262728293031node index.js// 输出对象Module &#123;id: '/Users/liyingqi/Desktop/demo/demo2/index2.js', // 模块的识别符，通常是带有绝对路径的模块文件名exports: &#123;&#125;, // 表示模块对外输出的值。parent: //返回一个对象，表示调用该模块的模块 Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: '/Users/liyingqi/Desktop/demo/demo2/index.js', loaded: false, //返回一个布尔值，表示模块是否已经完成加载 children: [ [Circular] ], //返回一个数组，表示该模块要用到的其他模块 paths: [ '/Users/liyingqi/Desktop/demo/demo2/node_modules', '/Users/liyingqi/Desktop/demo/node_modules', '/Users/liyingqi/Desktop/node_modules', '/Users/liyingqi/node_modules', '/Users/node_modules', '/node_modules' ] &#125;,filename: '/Users/liyingqi/Desktop/demo/demo2/index2.js', // 模块的文件名，带有绝对路径loaded: false, // children: [],paths: [ '/Users/liyingqi/Desktop/demo/demo2/node_modules', '/Users/liyingqi/Desktop/demo/node_modules', '/Users/liyingqi/Desktop/node_modules', '/Users/liyingqi/node_modules', '/Users/node_modules', '/node_modules' ] &#125; module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。为了方便Node为每个模块提供一个exports变量，指向module.exports1var exports = module.exports;（commonJS隐式做了这个赋值） 这样做的好处，对外输出模块接口时，可以向exports对象添加方法暴露出去,降低属性前缀对性能的损耗 require命令（1）Node使用common.js模块规范，内置的require命令用于加载模块文件，require的基本功能是，读入并且执行一个javascript文件，然后返回该模块的exports对象，如果没有发现指定模块会报错；require加载规则：require命令用于加载文件，后缀名默认为.js。123var foo = require(&apos;foo&apos;);// 等同于var foo = require(&apos;foo.js&apos;); 根据参数的不同格式，require命令去不同路径寻找模块文件:(1) 果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。（2）如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。绝对路径相对于ROOT（3）如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。从上到下依次查找12345678require(&apos;webpack&apos;) // 引用webpack, 从上到下依次查找；&apos;/Users/liyingqi/Desktop/demo/demo2/node_modules&apos;,&apos;/Users/liyingqi/Desktop/demo/node_modules&apos;,&apos;/Users/liyingqi/Desktop/node_modules&apos;,&apos;/Users/liyingqi/node_modules&apos;,&apos;/Users/node_modules&apos;,&apos;/node_modules&apos; // 全局 （4）如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。（5）如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。（6）如果想得到require命令加载的确切文件名，使用require.resolve()方法。 目录的加载规则： 通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载根据入口文件的依赖关系记载整个目录；在目录中放置一个package.json文件，并且将入口文件写入main字段当你加载一个npm包时候，require会根据你的入口文件进行加载； 模块缓存：第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。123456789101112131415161718192021222324252627282930313233343536373839&#123; [Function: require] resolve: &#123; [Function: resolve] paths: [Function: paths] &#125;, main: Module &#123; id: &apos;.&apos;, exports: &#123;&#125;, parent: null, filename: &apos;/Users/liyingqi/Desktop/demo/demo2/index.js&apos;, loaded: false, children: [ [Object] ], paths: [ &apos;/Users/liyingqi/Desktop/demo/demo2/node_modules&apos;, &apos;/Users/liyingqi/Desktop/demo/node_modules&apos;, &apos;/Users/liyingqi/Desktop/node_modules&apos;, &apos;/Users/liyingqi/node_modules&apos;, &apos;/Users/node_modules&apos;, &apos;/node_modules&apos; ] &#125;, extensions: &#123; &apos;.js&apos;: [Function], &apos;.json&apos;: [Function], &apos;.node&apos;: [Function] &#125;, cache: //模块缓存 &#123; &apos;/Users/liyingqi/Desktop/demo/demo2/index.js&apos;: Module &#123; id: &apos;.&apos;, exports: &#123;&#125;, parent: null, filename: &apos;/Users/liyingqi/Desktop/demo/demo2/index.js&apos;, loaded: false, children: [Array], paths: [Array] &#125;, &apos;/Users/liyingqi/Desktop/demo/demo2/index2.js&apos;: Module &#123; id: &apos;/Users/liyingqi/Desktop/demo/demo2/index2.js&apos;, // 模块id exports: [Object], parent: [Object], filename: &apos;/Users/liyingqi/Desktop/demo/demo2/index2.js&apos;, loaded: true, children: [], paths: [Array] &#125; &#125; &#125; 想要多次执行某个模块的话：12345678// 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) 循环引用问题： AMD 规范]]></content>
      <tags>
        <tag>AMD CMD es6模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2019%2F01%2F05%2FDOM%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络部分]]></title>
    <url>%2F2019%2F01%2F02%2F%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>http https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb mongoose]]></title>
    <url>%2F2018%2F12%2F02%2Fmongodb-mongoose%2F</url>
    <content type="text"><![CDATA[mongodb 介绍 mongoDB与一些关系型数据库相比，它更显得轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。同时它也是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储。由c++语言编写，是一个分布式文件存储的开源NoSQL数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。mongoDB旨在为web应用提供可扩展的高性能数据存储解决方案 mongoDB将数据存储为一个文档，数据结构由键值对组成。mongoDB文档类似于JSON对象，字段值可以包含其他文档、数组及文档数组。 分布式数据库系统通常使用较小的计算机系统，每台计算机可单独放在一个地方，每台计算机中都可能有DBMS的一份完整拷贝副本，或者部分拷贝副本，并具有自己局部的数据库，位于不同地点的许多计算机通过网络互相连接，共同组成一个完整的、全局的逻辑上集中、物理上分布的大型数据库 123// mac 下载brew updatebrew install mongodb 启动 从命令行启动 执行mongod，启动MongoDB服务器，mongod有很多可配置的启动选项，可以使用mongod –help查看所有选项 1mongod --config /usr/local/etc/mongod.conf 后台启动 –dbpath： 指定数据目录，默认是/data/db下，每个mongod进程都需要独立的数据目录，加入有3个mongod实例，就必须要有3个独立的数据目录。当mongod启动时，会在数据目录中创建mongod.lock文件。这个文件用于防止其他mongod进程使用该数据目录。若当有一个mongd启动后，再启动另一个mongod时，若再使用刚刚已经启动mongod的目录，那么会报错： 12017-07-06T16:03:09.703+0800 I STORAGE [initandlisten] exception in initAndListen: 98 Unable to lock file: mongodb/0706/mongod.lock Resource temporarily unavailable. Is a mongod instance initAndListenready running?, terminating –port： 指定服务器监听的端口号。默认端口号为27017，要是运行多个mongod，必须指定不同的端口号 若有一个27017的端口已经使用了，那么如果启动第二个mongod的时候，若还指定27017的话，会报错： mongoosemongoose是mongoDB的一个对象模型工具，是基于node-mongodb-native开发的mongoDB的nodejs驱动，可以在异步的环境下执行。同时它也是针对mongoDB操作的一个对象模型库，封装了mongoDB对文档的一些增删改查等常用方法，让nodejs操作mongoDB数据库变得更加容易。 model.js 1234567891011121314151617181920212223242526272829303132333435// npm install mongooseconst mongoose = require(&apos;mongoose&apos;)// 链接mongo 并且使用liyingiq这个集合const DB_URL = &apos;mongodb://localhost:27017/liyingqi-chat&apos;// 连接数据库mongoose.connect(DB_URL)// 数据模型const models = &#123; user:&#123; &apos;user&apos;:&#123;type:String, &apos;required&apos;:true&#125;, &apos;pwd&apos;:&#123;type:String, &apos;required&apos;:true&#125;, &apos;type&apos;:&#123;&apos;type&apos;:String, &apos;required&apos;:true&#125;, //头像 &apos;avatar&apos;:&#123;&apos;type&apos;:String&#125;, // 个人简介或者职位简介 &apos;desc&apos;:&#123;&apos;type&apos;:String&#125;, // 职位名 &apos;title&apos;:&#123;&apos;type&apos;:String&#125;, // 如果你是boss 还有两个字段 &apos;company&apos;:&#123;&apos;type&apos;:String&#125;, &apos;money&apos;:&#123;&apos;type&apos;:String&#125; &#125;&#125;for(let m in models)&#123; // 建表 存储数据 mongoose.model(m, new mongoose.Schema(models[m]))&#125;// 导出module.exports = &#123; getModel:function(name)&#123; return mongoose.model(name) &#125;&#125; server.js 12345678910111213141516171819let models = require(&apos;./model&apos;);let User = models.getModel(&apos;user&apos;);// 增加User.create(&#123;user: &apos;liyingqi&apos;&#125;, function (err, doc) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(doc); &#125;&#125;);// 删除User.remove(&#123;user: &apos;liyingqi&apos;&#125;, function (error) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;用户删除成功&quot;) &#125;&#125;); 查询数据 find 模糊查找，查找所有 123456789//查询所有密码为“123456”的文档记录userMode.find(&#123;&quot;pwd&quot;: &apos;123456&apos;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;密码为123456的个数：&quot;,docs.length) console.error(&quot;所有文档如下：\n&quot;,docs) &#125;&#125;); 日志信息 12345678910111213141516171819202122密码为1234567的个数： 4所有文档如下： [ &#123; _id: 587d7b4aa51c535f09b8cc41, name: &apos;tiny&apos;, password: &apos;1234567&apos;, age: 14, __v: 0 &#125;, &#123; _id: 587d7b56a51c535f09b8cc42, name: &apos;tinyjoy1&apos;, password: &apos;1234567&apos;, age: 18, __v: 0 &#125;, &#123; _id: 587d7b71a51c535f09b8cc44, name: &apos;tinyjoy3&apos;, password: &apos;1234567&apos;, age: 60, __v: 0 &#125;, &#123; _id: 587d7e2463260b78550e8366, name: &apos;tinyjoy2&apos;, password: &apos;1234567&apos;, age: 60, __v: 0 &#125; ] 属性过滤 find(Conditions,field,callback); 12345678// 查询密码为“1234567”的所有记录，返回文档记录只包含一个键值nameUser.find(&#123;&quot;password&quot;: userInfo.password&#125;,&#123;name:&quot;liyingqi&quot;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;查询结果：&quot;,docs) &#125;&#125;); 日志信息 1234查询结果： [ &#123; _id: 587d7b4aa51c535f09b8cc41, name: &apos;tiny&apos; &#125;,&#123; _id: 587d7b56a51c535f09b8cc42, name: &apos;tinyjoy1&apos; &#125;,&#123; _id: 587d7b71a51c535f09b8cc44, name: &apos;tinyjoy3&apos; &#125;,&#123; _id: 587d7e2463260b78550e8366, name: &apos;tinyjoy2&apos; &#125; ] findOne: 与find相同，但只返回单个文档，也就说当查询到即一个符合条件的数据时，将停止继续查询，并返回查询结果。findOne方法，只返回第一个符合条件的文档数据。 单条数据 findOne(Conditions,callback); 12345678// 查询密码为123456的一条记录 User.findOne(&#123;&quot;password&quot;: &apos;123456&apos;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;查询结果：&quot;,docs) &#125; &#125;); 日志信息 12345查询结果： &#123; _id: 587d7b4aa51c535f09b8cc41, name: &apos;tiny&apos;, password: &apos;1234567&apos;, age: 14, __v: 0 &#125; findById 与findOne相同，但它只接收文档的_id作为参数，返回单个文档。单条数据 findById(_id, callback);条件查询 “$lt”(小于)，”$lte”(小于等于),”$gt”(大于)，”$gte”(大于等于)，”$ne”(不等于)，”$in”(可单值和多个值的匹配)，”$or”(查询多个键值的任意给定值)，”$exists”(表示是否存在的意思)”$all”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//查询年龄小于18的所有记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$lt&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;查询结果：&quot;, doc) &#125;&#125;);//查询年龄小于等于18的所有记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$lte&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;查询结果：&quot;, doc) &#125;&#125;);//查询年龄不等于18的所有文档记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$ne&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;年龄不等于18的查询结果：&quot;, doc) &#125;&#125;);//查询年龄大于18的所有文档记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$gt&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;年龄大于18的查询结果：&quot;, doc) &#125;&#125;);//查询年龄大于等于18的所有文档记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$gte&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;年龄大于等于18的查询结果：&quot;, doc) &#125;&#125;);//查询年龄大于等于18小于等于60所有文档记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$gte&quot;: 18, &quot;$lte&quot;: 60&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;年龄大于等于18小于等于60查询结果：&quot;, doc) &#125;&#125;); “$in”和$nin’ 1234567891011121314151617181920212223242526//查询年龄等于18的所有记录userMode.find(&#123;age:&#123;$in: 18&#125;&#125;,function (error,doc) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;年龄为18的查询结果：&quot;,doc) &#125;&#125;); //查询年龄等于18和19的所有记录userMode.find(&#123;age:&#123;&quot;$in&quot;:[18,19]&#125;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;年龄为18和19的查询结果：&quot;,docs) &#125;&#125;); //查询年龄不等于18和19的所有记录userMode.find(&#123;age:&#123;&quot;$nin&quot;:[18,19]&#125;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;年龄不等于18和19的查询结果：&quot;,docs) &#125;&#125;); $Or或查询： 1234567891011121314151617//查询年龄等于18或者名字为tiny所有记录userMode.find(&#123;&quot;$or&quot;: [&#123;&quot;name&quot;: &quot;tiny&quot;&#125;, &#123;&quot;age&quot;: 18&#125;]&#125;, function (error, docs) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;$or查询结果：&quot;, docs) &#125;&#125;); //查询年龄不等于18且名字不为tiny所有记录userMode.find(&#123;&quot;$nor&quot;: [&#123;&quot;name&quot;: &quot;tiny&quot;&#125;, &#123;&quot;age&quot;: 18&#125;]&#125;, function (error, docs) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;$nor查询结果：&quot;, docs) &#125;&#125;); exist查询： $exists操作符，可用于判断某些关键字段是否存在来进行条件查询 12345678//查询所有存在name属性的文档userMode.find(&#123;name: &#123;$exists: true&#125;&#125;, function (error, docs) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;exists查询结果：&quot;, docs) &#125;&#125;);]]></content>
      <tags>
        <tag>mongodb mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域]]></title>
    <url>%2F2018%2F11%2F26%2F%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-js%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[作用域 几乎所有的编程语言最基本的功能，储存变量中的值，并且之后对这个值进行访问和修改，这些值存在哪里，我们如何获取他们？这些问题说明我们需要设计一套良好的规则来储存变量，并且之后可以方便地找到这些变量，这些规则我们称作“作用域” javascript 运行原理 javaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度 解析性语言： 边解释边执行 源代码===&gt; 抽象语法树 ===&gt;解析器解析和执行 编译性语言：先编译在执行 源代码===&gt; 抽象语法树 ===》中间表示形式 ===》本地代码 JavaScript语言是解释型语言，为了提高性能，引入了Java虚拟机和C++编译器中的众多技术。现在JavaScript引擎的执行过程大致是： 源代码-→抽象语法树-→字节码-→JIT（just in time 即时编译）-→本地代码（v8没有中间字节码）V8更加直接的将抽象语法树通过JIT技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。 但是在2017年4月底，v8 的 5.9 版本发布了，新增了一个 Ignition 字节码解释器，将默认启动，从此之后将与JSCore有大致相同的流程。做出这一改 变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度 因为之前 v8 选择了直接将 JS 代码编译到机器代码执行，机器码的执行性能已经非常之高，而这次引入字节码则是选择编译 JS 代码到一个中间态的字节码，执行时是解释执行，性能是低于机器代码的。最终的性能测试势必会降低，而不是提高。那么 V8 为什么要做这样一个退步的选择呢？为 V8 引入字节码的动机又是什么呢？笔者总结下来有三条： –（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间 – 提高代码的启动速度 – 对 v8 的代码进行重构，降低 v8 的代码复杂度 故事得从 Chrome 的一个 bug 说起： http://crbug.com/593477 。Bug 的报告人发现，当在 Chrome 51 (canary) 浏览器下加载、退出、重新加载 facebook 多次，并打开 about:tracing 里的各项监控开关，可以发现第一次加载时 v8.CompileScript 花费了 165 ms，再次加载加入 V8.ParseLazy 居然依然花费了 376 ms。按说如果 Facebook 网站的 js 脚本没有变，Chrome 的缓存功能应该缓存了对 js 脚本的解析结果，不该花费这么久。这是为什么呢？这就是之前 v8 将 JS 代码编译成机器码所带来的问题。因为机器码占空间很大，v8 没有办法把 Facebook 的所有 js ,代码编译成机器码缓存下来，因为这样不仅缓存占用的内存、磁盘空间很大，而且退出 Chrome，再打开时序列化、反序列化缓存所花费的时间也很长，时间、空间成本都接受不了。所以 v8 退而求其次，只编译最外层的 js代码，也就是下图这个例子里面绿色的部分。那么内部的代码（如下图中的黄色、红色的部分）是什么时候编译的呢？v8推迟到第一次被调用的时候再编译。这时间上的推移还导致另外一个短板，就是代码必须被解析多次——绿色的代码一次、黄色的代码再解析一次（当 new Person 被调用）、红色的代码再解析一次（当 doWork() 被调用）。因此，如果你的 js 代码的闭包套了 n 层，那么最终他们至少会被 v8 解析 n 次。 Facebook 的网站之所以收到这个设计带来的负面的性能影响，就是因为他们的前段工程流程中最后把各个独立的 module 编译成了一个单独的文件，其中用到了很多闭包 刚才提到了机器码占空间大的一个坏处，就是不能一次性编译全部的代码。机器码占空间大还有另外一个坏处，就是一些只运行一次的代码浪费了宝贵的内存 资源。正如上面 Facebook 中的 __d() 系列函数，他们的作用可能只是注册、初始化各个模块组件，而一旦初始化完成便不会再执行。但由于机器码占空间大，这些只执行一次的代码也会在内存中长期存在、长期占用空间。 而引入字节码之后(进行代码优化)，占空间的问题就可以得到缓解。通过恰当地设计字节码的编码方式，字节码可以做到比机器码紧凑很多。V8 引入Ignition 字节码后，代码的内存占用确实降低了； 预编译 javascript引擎主要负责整个javascript程序编译及执行过程；作用域：引擎的一个好朋友，负责收集和维护所有声明的标识符，组成的一系列查询，并实施一套非常严格的规则，确定当前代码对这些标识符的访问权限； 总的来说：js运行 词法分析 语法分析（AST）,预编译，解析执行 语法分析和预编译发生在解析执行之前； 1.词法分析：将字符组成的字符串分解成（对编程语言来说有意义）的代码块，这些代码块称为词法单元 2.语法分析：这个过程将词法单元流转换成一个由元素逐级嵌套组成的代表了js程序语法的结构的树 预编译分类：全局预编译：脚本代码块script执行前,查找全局变量声明（包括隐式全局变量声明,省略var声明变量名作全局对象的属性,值为undefined函数预编译： 预编译(函数执行前)※ 1.创建AO对象（Active Object） 2.查找函数形参及函数内变量声明，形参名及变量名作为AO对象的属性，值为undefined 3.实参形参相统一，实参值赋给形参 4.查找函数声明，函数名作为AO对象的属性，值为函数引用解析执行：解析执行编译好的机械码（预编译阶段将抽象语法树转为中间字节码通过jit转为机械码） 举例：1234567891011121314&lt;script&gt; var a = 1;// 变量声明 function b(y)&#123;//函数声明 var x = 1; console.log('so easy'); &#125;; var c = function()&#123;//是变量声明而不是函数声明！！ //... &#125; b(100);&lt;/script&gt;&lt;script&gt; var d = 0;&lt;/script&gt; 看看javascript引擎对这段代码做了什么？ 1.页面产生便创建了GO全局对象（Global Object）（也就是大家熟悉的window对象） 2.第一个脚本文件加载 3.脚本加载完毕后，分析语法是否合法 4.开始预编译 5.查找变量声明，作为GO属性，值赋予undefined 6.查找函数声明，作为GO属性，值赋予函数体 伪代码：123456789GO/window = &#123; //页面加载创建GO同时，创建了document、navigator、screen等等属性，此处省略 a: undefined, c: undefined， b: function(y)&#123; var x = 1; console.log('so easy'); &#125;&#125; 执行函数b之前，发生预编译 创建AO活动对象（Active Object） 查找形参和变量声明，值赋予undefined 实参值赋给形参 查找函数声明，值赋予函数体 12345AO = &#123; //创建AO同时，创建了arguments等等属性，此处省略 y: 100, x: undefined&#125; javascript解释执行函数中代码 第一个脚本文件执行完毕，加载第二个脚本文件 第二个脚本文件加载完毕后，进行语法分析 语法分析完毕，开始预编译 重复最开始的预编译步骤… 执行环境及作用域执行环境（有时也称为环境）也被尘称为执行期上下文:执行环境定义了变量和函数并提供了执行他们的环境，每个执行环境都有一个与之关联的变量对象，环境中的变量对象和函数都保存在这个对象中；全局执行环境：宿主环境不同表示的执行对象也不同，游览器中window;函数执行环境：当执行流进入一个函数时，函数环境被推入一个环境栈中，而在这个函数执行之后，栈将其弹出； 销毁：某个执行环境中的代码和方法执行完之后，改环境被销毁，保存在其中所有变量和函数定义也都被随之销毁（全局执行环境直到应用退去才被销毁） 大白话： 当函数执行时，会创建一个执行期上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境，函数每次执行时定义的执行期上下文都是不一样的；当函数执行完毕，他所产生的执行期上下文销毁； 作用域链： 函数内部的[[scope]]属性：在我们创建函数时就会生成这样的一个属性，这个属性保存着这个函数的父作用域的作用域链；在函数执行时，函数会生成一个活动对象（执行期上下文）放到[[scope]]最前端，[[scope]]属性中存在的执行期上下文集合，就是我们常说的作用域链； 当代码在一个环境中执行时，会创建变量（函数）对象的一个作用域链(scope chain);作用域链的用途，是创建的函数保证对执行环境中变量和函数有序的访问； 活动对象：作用域的最前端，是当前执行函数所在的执行环境，将其活动对象（activation object）作为变量的对象；12345678910111213// sort 比较函数function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0 &#125;&#125;compare(5, 10); 后台的每一个执行环境都有一个表示变量的对象—变量对象、全局环境的变量对象始终存在，像compare()，函数这样局部环境变量对象只在函数执行过程中存在。 创建compare()函数的时候，会创建一个预先包含全局变量对象（global|| window）的作用域链，这个对象被保存在函数内部的[[scope]]属性中；( 发生在预编译阶段) 执行compare()函数的时候，会为函数创建一个执行环境，然后通过复制[[scope]]属性中的对象构建起执行环境的作用域链；（发什么在解析执行阶段） 此后又有一个活动对象被创建，被推入执行队列的最前端 垃圾回收机制javascript具有自动回收垃圾机制的，也就是说，执行环境会负责管理代码执行过程中使用的内存，而在c和c++之类的语言中，开发人员一项基本任务是手动的跟踪内存的使用情况，这也是造成许多问题的根源。在编写javascript程序时，开发人员不用在担心内存的使用哪个问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾回收机制很简单：找出那些不在继续使用的变量，然后释放其占用的内存，为此垃圾回收器会按照固定的时间间隔（或者代码执行中预定的收集时间）周期性的执行这一个操作。局部变量的生命周期，局部变量只有在函数执行的过程中存在，在这个过程中，会为局部变量在栈或者堆内存上分配相应的空间，一遍储存他们的值。然后在函数中使用这些变量，直到函数执行结束。此时局部变量没有存在的必要了，因此可以释放他们的内存以供将来使用；全局变量的生命周期直到游览器卸载页面才会结束； 标记清除 这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间； 举例： 12345var a = 3;function b() &#123; var c = 7;&#125;b(); 预编译之后解析执行： 函数执行时启动垃圾回收机制，将c标记为进入环境，执行完之后将其标记为离开环境；这中间，垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量；闭包函数的生命周期还没有结束； 闭包 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的常用方式，就是在函数内部，创建另一个函数；来自===》高级程序设计 12345678function foo() &#123; var a = 2; function bar() &#123; console.log('a'); &#125; bar();&#125;foo(); 上面也可以说是闭包；但是不是很明显，bar中对a的引用是作用域的查找规则； 我查阅你不知道的javascript和高级程序设计总结出自己理解的闭包： 1.函数嵌套函数 2.函数中有对另一个函数作用域中变量的引用 3.原有作用域链不被销毁，垃圾回收机制不能进行回收 123456789function foo() &#123; var a = 2; function b() &#123; console.log('a'); &#125; return b;&#125;var limit = foo();limit(); 当定义foo时将全局执行环境对象复制到了foo函数的[[scope]]属性中；执行foo时创建foo的活动对象放到[[scope]]的最前端定义b函数时，复制foo函数的[[scope]]放到b函数的[[scope]]属性中；正常当foo函数执行完之后，我们常常期望，foo的整个内部作用域被销毁，因为我们知道引擎有垃圾回收器用来释放不在使用的内存空间。但是在我们这个例子中作用域依然存在，执行limit()输出为2；谁在使用这个内部作用域？ 拜b()所声明的位置决定，他拥有富含foo()内部作用域的闭包（引用），使得改作用域一直存活；以供b()在之后任何位置引用，b()依然持有该作用于的引用，这个引用称作闭包；高级程序设计有很好的图；180页； 常见闭包问题：定时器闭包 123456function wait(message) &#123; setTimeout(function timer() &#123; console.log('message') &#125;, 1000)&#125;wait('hello closure'); 将一个内部函数timer函数传递給setTimeout(),timer具有蕴含wait作用域的引用（闭包);wait()执行完之后期作用域没有消失，1秒后执行timer,timer执行完之后销毁执行期上下文；（这里涉及到执行队列，异步相关知识，之后总结）;所以少用setTimeInterval()，他会一直执行，导致作用域链不被释放；闭包有很多应用：在定时器，事件监听器，ajax请求，跨窗口通信，使用回调函数，就是在使用闭包； 循环和闭包12345for(var i=1;i&lt;=5;i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125; 我们期望输出,1,2,3,4,5，但是他输出的是5个6；为什么呢？循环总是先结束的，即使时间间隔为0;循环结束之后全局变量i；变为6；执行异步代码执行timer，创建执行期上下文，引擎根据查找规则找，沿着作用域链进行查找，执行期上下文对象里面没有，向全局作用域查找,此时全局i变为6；输出为6； 怎么能得到预期的结果呢？缺陷：假设循环中的每个迭代在运行时候都会给自己捕获一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中五个函数是在各个迭代中分别定义的，但是他们被封闭在一个共享的全局作用域中，实际上只有一个i；如果我们通过在外层增加一个函数，将timer封装在函数作用域中，通过引用函数执行期上下文中的j(j=i)，不就好了吗？ 12345678for(var i=1;i&lt;=5;i++) &#123; (function(j)&#123; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000) &#125;)(i)&#125;// 输出 1，2，3，4，5 立即执行函数，会为某个迭代生成一个新的作用域，我们可以引用新的作用域的值； 我们使用立即执行函数时每次迭代时候会创建一个新的作用域，换句话说每次迭代都需要一个块级作用域；es6提出块作用域，与之相关的变量声明，let,const； let let关键字可以将《变量》绑定到所在的任意作用域中（通常是{….}内部），换句话说，let为其声明的变量隐试地劫持了所在的块作用域；隐式块作用域,函数不可隐式的劫持块作用域；123456if() &#123; let a = 3;&#125; for() &#123; let a = 3;&#125; 通过打断点，当let显示，或者隐式绑定块作用域时，当执行块中的代码时，会在作用域链的前端加上Block的活动对象这个活动对象里面只包含，在块中let声明的变量，当执行完代码块中的代码时，垃圾回收机制释放Block执行上下文的内存；这也是，在别的作用域中访问不到，let声明的变量的值原因；可以显示的定义块作用域,显示的加上{};当执行函数d时候，会产生执行期上下文图中scope下面的local对象，local里面有let定义的d变量，f变量，如果块作用域中，有var，函数声明的话都提到local中； 如图：当js引擎执行到代码块中时，会在[[scope]]属性的最前端加上Block的作用域（执行期上下文），这个对象中只包含let和const声明的变量； 如图：当代码块中代码执行完之后，活动对象会被垃圾回收器回收； 12345678for(var i=1;i&lt;=5;i++) &#123; &#123; let j = i; setTimeout(function timer() &#123; console.log(j); &#125;, i*1000) &#125;&#125; let将j变量显示的绑定到了块级作用域上，每一次迭代生成新的块级作用域，相当于上面的立即执行函数方法；在全局与函数作用域之间加上一个块级作用域，timer回调函数被Block执行环境所包裹，每一次都取不同的变量j;得到预期的结果；改进：12345for(let i=1;i&lt;=5;i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125; for循环中(){}块级作用域是父子关系；for循环中的let声明，有一个特殊的行为，这个行为指出变量在循环过程中不止声明一次，随后的每个迭代都会使用上一次迭代结束的值初始化这个变量；每次迭代let将i绑定到新的块级作用域上，timer中的i访问Block中的i，得到预期的结果（看不懂断点），使用这种方式避免了全局污染，并且，timer中的代码执行完，将释放掉leti绑定的块级作用域的空间（垃圾回收） 块级作用域和let的关系： 通过let,const将变量绑定到块级作用域； 总结： 1.let 声明的变量，不存在变量提升，比较好控制 2.let 声明的变量，存在暂时性死区，绑定变量于相应块级作用域内、外部相同变量的声明无法修 改作用域内变量 3.let 声明的变量，在相同作用域内，不允许重复声明 4.垃圾收集，如上例子，执行完timer之后，立即释放它的父块级作用域； 还有一些其他的代码模式利用了闭包强大的威力，之后我会用一些篇幅来研究其中最强大的一块：模块； 参考： 你不知道的javascript; 高级程序设计 JS 引擎与字节码的不解之缘: 网址 v8引擎详解: 网址]]></content>
      <tags>
        <tag>闭包 作用域链 javascript编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux]]></title>
    <url>%2F2018%2F11%2F22%2Fredux%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[regExp]]></title>
    <url>%2F2018%2F11%2F16%2FregExp%2F</url>
    <content type="text"><![CDATA[正则表达式的作用 匹配特殊字符或有特殊匹配原则的字符的最佳选择 转义字符：\ 和特殊字符组合有特殊功能，\n回车； 和级特殊的字符组合如转义字符，能输出转义字符，回车和转义字符都是极特殊字符； 123456var str = &apos;l\nq&apos;;&apos;lnq&apos;str = &apos;l\\nq&apos;;&apos;l\nq&apos; 正则表达式写法 （1）字面量 var regExp = //; /正则表达式主体/修饰符(可选) (2) 创建 RegExp 对象的语法 var reg = new RegExp(pattern, attributes); 参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。 参数 attributes 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。 两者的主要区别： 1.采用直接量语法新建的正则表达式对象在代码编译时就会生成，是平常开发中常用的方式 2.采用构造函数生成的正则对象要在代码运行时生成。 正则表达式的属性和方法： ignoreCase 返回Boolean，表示regExp是否有表示i; global 返回布尔值，表示RegExp对象是否具有标志g multiline 返回布尔值，表示RegExp 对象是否具有标志 m。 lastIndex 一个整数，标识开始下一次匹配的字符位置; source 返回正则表达式的源文本（不包括反斜杠） i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配 正则表达式作用 （1）验证： 用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串； （2）搜索替换： 搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和$ 字符类匹配 […] 查找方括号之间的任何字符 [^…] 查找任何不在方括号之间的字符 [a-z] 查找任何从小写 a 到小写 z 的字符 [A-Z] 查找任何从大写 A 到大写 Z 的字符 [A-z] 查找任何从大写 A 到小写 z 的字符 . 查找单个字符，除了换行和行结束符 \w 查找单词字符，[a-zA-Z0-9_] \W 查找非单词字符，等价于[^a-zA-Z0-9] \s 查找空白字符 \S 查找非空白字符 \d 查找数字，等价于[0-9] \D 查找非数字字符，等价于[^0-9] \b 匹配单词边界 \B 匹配非单词边界 \r 查找回车符 \t 查找制表符 \0 查找 NULL 字符 \n 查找换行符 重复字符匹配： {n,m} 匹配前一项至少n次，但不能超过m次 {n,} 匹配前一项n次或更多次 {n} 匹配前一项n次 n？ 匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0，1} n+ 匹配前一项1次或多次，等价于{1，} n* 匹配前一项0次或多次，等价于{0，} n$ 匹配任何结尾为 n 的字符串 ^n 匹配任何开头为 n 的字符串 ?=n 匹配任何其后紧接指定字符串 n 的字符串 12345var str = &apos;aaaBaaac&apos;;var reg = /(?=[A-Z])/; // 匹配挨着[A-Z]的字符串 用于插入字符串片段;str.split(reg);// [&apos;aaa&apos;, &apos;Baaac&apos;] ?!n 匹配任何其后没有紧接指定字符串 n 的字符串 匹配特定数字 ^[1-9]\d$ 匹配正整数 ^-[1-9]\d$ 匹配负整数 ^-?[0-9]\d$ 匹配整数 ^[1-9]\d|0$ 匹配非负整数（正整数 + 0） ^-[1-9]\d|0$ 匹配非正整数（负整数 + 0） ^[1-9]\d.\d|0.\d[1-9]\d$ 匹配正浮点数 ^-([1-9]\d.\d|0.\d[1-9]\d)$ 匹配负浮点数 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 匹配浮点数 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d.\d|0.\d[1-9]\d*))|0?.0+|0$ 匹配非正浮点数（负浮点数 + 0） 匹配特定字符串： ^[A-Za-z]+$ 匹配由26个英文字母组成的字符串 ^[A-Z]+$ 匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ 匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ 匹配由数字和26个英文字母组成的字符串 ^\w+$ 匹配由数字、26个英文字母或者下划线组成的字符串 正则表达式的属性和方法： test:如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。 12345var reg = /abc/g;var str = &quot;123abc456abc&quot;;reg.test(&apos;b&apos;);// true; exec方法: exec() 方法用于检索字符串中的正则表达式的匹配 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null 全局匹配:exec方法也是匹配字符串中所有满足条件的结果，但是默认只能返回第一次匹配到的结果, 得手动调用； 数组里面得值： 123456var regExp = /\w/g; // 全局匹配var returnValue = regExp.exec(&apos;123&apos;);// [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined] (第一次)// [&quot;2&quot;, index: 1, input: &quot;123&quot;, groups: undefined] (第2次) 子表达式的反向引用： 匹配： &apos;abba&apos;形式的字符串 1234var reg = /([A-z])([A-z])\2\1/;var str = &apos;abba&apos;;reg.test(str);// true; 型如&apos;aabb&apos; 12345var reg = /([A-z])\1([A-z])\2/;var str = &apos;aabb&apos;;reg.test(str);// true; 形如&apos;abab&apos;; 1234var reg = /([A-z])([A-z])\1\2/;var str = &apos;abab&apos;;reg.test(str);// true; 字符串的方法 search方法：方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 返回值： stringObject 中第一个与 regexp 相匹配的子串的起始位置。 注释：如果没有找到任何匹配的子串，则返回 -1。 search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 1234var str = &apos;abca&apos;;str.search(/a/g);// 0 match方法: match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。 字符串对象的match方法与正则对象的exec方法比较类似： 但是如果正则表达式带有g修饰符，那么match方法与exec方法就有差别了: 可以看到match返回了所有成功匹配的结果，但是exec方法只返回了一个 replace方法: replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 参数： | 参数 | 描述 | | :—— | | regexp/substr | 必须, 规定子字符串或者要替换的模式的 RegExp 对象 | | replacement | 必须、；一个字符串值规定了替换文本或者生成替换文本的函数 | 返回值：一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。 字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement可以是子字符串也可以是函数。如果是子字符串那么每个匹配都将由子符串进行替换， 但是replacement中的$字符有特定的含义，$1、$2、…、$99， 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 replacement 为函数的时候; 函数第一个参数为第一次匹配到的字符串，第二个参数为匹配到的第一个子表达式, 第三个参数为第二个子表达式， 如下： 12345678910111213var str = &apos;the-first-name&apos;;var reg = /-(\w)/g;str.replace(reg, (match, $1)=&gt; &#123; // 匹配到几个就执行几次 执行两次 console.log(match, $1); // -f f // -n n // 返回 替换的字符串 return $1.toUpperCase();&#125;);// 返回值 theFirstName 123456789101112var str = &apos;liyingqi&apos;;var returnValue = str.replace(&apos;i&apos;);console.log(returnValue); // &quot;lundefinedyingqi&quot; // &apos;不写第二个参数&apos; 默认由undefined 替换匹配到的字符串；var str = &apos;liyingqi&apos;;var returnValue = str.replace(&apos;f&apos;);console.log(returnValue); // 没匹配到， 返回全部字符串var str = &apos;liyingqi&apos;;var returnValue = str.replace(&apos;i&apos;, &apos;pp&apos;);console.log(returnValue); // &quot;lppyingqi&quot; // substr，匹配子字符串; 只替换第一个子串；// 经典案例： 驼峰转化为中划线 形如： liYingQi ===&gt; li-ying-qi 1234567891011121314151617181920212223242526272829303132333435363738394041424344var reg = /([A-Z])/g;var str = &apos;liYingQi&apos;;// 匹配第一个子表达式var returnValue = str.replace(reg, &apos;-$1&apos;).toLowerCase();console.log(returnValue); // &quot;li-ying-qi&quot;// 封装方法function middleLine(str) &#123; return str.replace(/\B([A-Z])/g, &apos;-$1&apos;).toLowerCase();&#125;middleLine(&apos;liYingQi&apos;); // li-ying-qi;// 严谨一点function middleLine(str) &#123; // 类型判断 var lock; lock = typeof str === &apos;string&apos; &amp;&amp; str ? false : true; if (lock) &#123; return false; &#125; return str.replace(/\B([A-Z])/g, (match)=&gt; &#123; return `-$&#123;match.toLowerCase()&#125;`; &#125;);&#125; // 推荐使用 npm包humps, 有很多方法， 源码 https://github.com/domchristie/humps/blob/master/humps.js参考了一下: humps, 增加扩展性option : separator 分隔符 split 自定义拆分正则； function middleLine (string, option) &#123; var lock; lock = typeof string === &apos;string&apos; &amp;&amp; string ? false : true; if (lock) &#123; return false; &#125; option = option || &#123;&#125;; var separator = option.separator || &apos;-&apos;; var split = option.split || /(?=[A—Z])/; return string.split(split).join(separator).toLowerCase();&#125; (?:) // 不记录子表达式内容； split方法： split(‘字符串的分割正则’,’返回数组的最大成员数’)；返回分割后各部分组成的数组； humps 源码解读 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133;(function(global) &#123; // 转化对象中的name的写法 递归方法 var _processKeys = function(convert, obj, options) &#123; if(!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) &#123; return obj; &#125; var output, i = 0, l = 0; if(_isArray(obj)) &#123; output = []; for(l=obj.length; i&lt;l; i++) &#123; output.push(_processKeys(convert, obj[i], options)); &#125; &#125; else &#123; output = &#123;&#125;; for(var key in obj) &#123; if(Object.prototype.hasOwnProperty.call(obj, key)) &#123; output[convert(key, options)] = _processKeys(convert, obj[key], options); &#125; &#125; &#125; return output; &#125;; // 字符串转换方法 var separateWords = function(string, options) &#123; options = options || &#123;&#125;; var separator = options.separator || &apos;_&apos;; // /(?=[A-Z])/ 紧挨着 大写字母的’‘； var split = options.split || /(?=[A-Z])/; return string.split(split).join(separator); &#125;; // 将形如 \ - _ 改写小驼峰写法 var camelize = function(string) &#123; if (_isNumerical(string)) &#123; return string; &#125; string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) &#123; return chr ? chr.toUpperCase() : &apos;&apos;; &#125;); // 保持第一个字符一直是小写 return string.substr(0, 1).toLowerCase() + string.substr(1); &#125;; // 首字符大写的大驼峰写法 var pascalize = function(string) &#123; var camelized = camelize(string); // 确定第一个字符一直是大写 // 截取第一位变成大写 + 从索引为1一直截取到最后的字符串 return camelized.substr(0, 1).toUpperCase() + camelized.substr(1); &#125;; // 驼峰变为- \ _ decamelize(&apos;liYingQi&apos;); var decamelize = function(string, options) &#123; return separateWords(string, options).toLowerCase(); &#125;; // Utilities // Taken from Underscore.js var toString = Object.prototype.toString; var _isFunction = function(obj) &#123; return typeof(obj) === &apos;function&apos;; &#125;; var _isObject = function(obj) &#123; return obj === Object(obj); &#125;; var _isArray = function(obj) &#123; return toString.call(obj) == &apos;[object Array]&apos;; &#125;; var _isDate = function(obj) &#123; return toString.call(obj) == &apos;[object Date]&apos;; &#125;; var _isRegExp = function(obj) &#123; return toString.call(obj) == &apos;[object RegExp]&apos;; &#125;; var _isBoolean = function(obj) &#123; return toString.call(obj) == &apos;[object Boolean]&apos;; &#125;; // 判断传入对象是数字的最高效率的方法 var _isNumerical = function(obj) &#123; obj = obj - 0; return obj === obj; &#125;; //设置方法 //允许通过回调修改convert函数 var _processor = function(convert, options) &#123; var callback = options &amp;&amp; &apos;process&apos; in options ? options.process : options; if(typeof(callback) !== &apos;function&apos;) &#123; return convert; &#125; return function(string, options) &#123; return callback(string, convert, options); &#125; &#125;; var humps = &#123; camelize: camelize, decamelize: decamelize, pascalize: pascalize, depascalize: decamelize, camelizeKeys: function(object, options) &#123; return _processKeys(_processor(camelize, options), object); &#125;, decamelizeKeys: function(object, options) &#123; return _processKeys(_processor(decamelize, options), object, options); &#125;, pascalizeKeys: function(object, options) &#123; return _processKeys(_processor(pascalize, options), object); &#125;, depascalizeKeys: function () &#123; return this.decamelizeKeys.apply(this, arguments); &#125; &#125;; // 定义导出方式 是AMD, CMD 规范 if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; define(humps); &#125; else if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = humps; &#125; else &#123; global.humps = humps; &#125;&#125;)(this);]]></content>
      <tags>
        <tag>regExp 正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-常见面试题]]></title>
    <url>%2F2018%2F11%2F16%2Fjs-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常见的数组面试题； 数组去重： Es5 12345678910111213141516171819202122232425262728293031function unique(arr) &#123; var newArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) === -1) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;function unique(arr) &#123; var newArr = [], newObj = &#123;&#125;, arrVal, type, objVal; for (var i = 0; i &lt; arr.length; i++) &#123; arrVal = arr[i]; objVal = newObj[arrVal]; type = typeof arrVal; console.log(objVal, arrVal); if (!objVal) &#123; newObj[arrVal] = [type]; newArr.push(arrVal); &#125; else if (objVal.indexOf(type) == -1) &#123; newObj[arrVal] = [type]; newArr.push(arrVal); &#125; &#125; return newArr;&#125; Es6 123[...new Set([1,2,1,1,1])];Array.from(new Set([1,2,1,1,1])) 排序sort sort() 方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串Unicode码点。 语法：arrayObject.sort(sortby)；参数sortby可选。规定排序顺序。必须是函数。 注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 1234567891011121314151617var data = [ &#123;age: 15, name:101&#125;, &#123;age: 19, name: 100&#125;, &#123;age: 15, name: 130&#125;, &#123;age: 15, name: 120&#125;, &#123;age: 19, name: 99&#125;, &#123;age: 19, name: 88&#125; ]; data.sort(function (a, b) &#123; // 年龄相等按照 name排列 if (a.age === b.age) &#123; return a.name - b.name; &#125; return a.age - b.age; &#125;); console.log(data) 打乱数组 1234567891011121314arr.sort(function()&#123; return 0.5 - Math.random() &#125;)var str=arr.join();alert(str);//打乱数组 循环随机位交换法var arr = [1, 2, 3,4,5]for (var i = 0; i &lt; arr.length; i++) &#123; var x = Math.floor(Math.random() * (length - 1)); var y = Math.floor(Math.random() * (length - 1)); var temp = arr[x]; arr[x] = arr[y]; arr[y] = temp;&#125;console.log(arr); 找出重复出现最多次的字母 12345678910111213141516171819202122232425262728293031323334 var str = &apos;abababcccccababab&apos;; var obj = str.split(&apos;&apos;).reduce((initData, ele, index, arr)=&gt; &#123; initData[ele] = initData[ele] ? ++initData[ele] : 1; return initData; &#125;, &#123;&#125;) console.log(obj); // &#123;a: 6, b: 6, c: 5&#125; function FindMaxChar (str) &#123; //长度唯一，返回 if (str.length === 1) &#123; return str; &#125; var obj = &#123;&#125;; //charAt返回字符串的字符 for (var i = 0; i &lt; str.length; i++) &#123; if (!obj[charAt(i)]) &#123; obj[charAt(i)] = 1; &#125; else &#123; obj[charAt(i)] += 1; &#125; &#125; var strValue = &apos;&apos;, maxChar; for ( var k in obj) &#123; //判断哪个字母出现的频率最高，把频率最高的输出出去 if (obj[k] &gt;= strValue ) &#123; maxChar = k; strValue = obj[k] ; &#125; &#125; return maxChar;&#125; 变量交换 实现a, b的交换 12345678function swap(a,b) &#123; var c; c = a; a = b; b = c; return [a,b]&#125;console.log(swap(a, b)); // 生成斐波那契数组的方法 1 1 2 3 5… 1234567891011121314151617181920212223242526272829303132333435 function fn(n) &#123; if (n === 1 || n === 2) &#123; return 1; &#125; return fn(n - 1) + fn(n - 2); &#125; fn(4); var a1=1; var a2=1; var a3=0; for(var i=2;i&lt;=n;i++)&#123;//因为前两个数都是1，所以要从i=2开始，就是前两个数的1+1=2，i的初始值其实是第三个数 a3=a1+a2;//第三个数等于第一个数加上第二个数 a1=a2;//第一个数就变成了之前的第二个数 a2=a3;//第二个数就变成了刚刚的第三个数 &#125; // 斐波那契数列数组function getFibonacci(n) &#123; var fibarr = []; var i = 0; while (i &lt; n) &#123; if (i &lt;= 1) &#123; fibarr.push(i); &#125;else &#123; fibarr.push(fibarr[i - 1] + fibarr[i - 2]); &#125; i++; &#125; return fibarr;&#125;console.log(fabonacci(5)); 递归全排列，打印n个数的全排列， n = 3;则这三个数1，2，3的全排列有： 1 深度克隆 12345678910111213141516171819202122232425262728293031323334353637383940function deepClone(target) &#123; var newContent = Array.isArray(target) ? [] : &#123;&#125;; var copy; for (var prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; copy = target[prop]; // 防止循环引用 if (copy === target) &#123; newContent[prop] = copy; continue; &#125; if (Array.isArray(copy) &amp;&amp; isPlainObject(copy)) &#123; newContent[prop] = deepClone(copy); &#125; else &#123; newContent[prop] = copy; &#125; &#125; &#125; return newContent;&#125;// 判断纯对象 字面量 new Object() 创建的function isPlainObject(obj) &#123; var proto; var Ctor; var hasOwn = &#123;&#125;.hasOwnProperty; if (!obj &amp;&amp; Object.prototype.toString.call(obj) !== &apos;[object Object]&apos;) &#123; return false; &#125; // 获取原型 proto = Object.getPrototypeOf(obj); // Object.create(null) if (!proto) &#123; return true; &#125; // 由全局Object对象构建的对象是普通对象，抛出了自定义构造函数的实例对象 // 实例对象 Ctor = hasOwn.call(proto, &apos;constructor&apos;) &amp;&amp; proto.constructor; return typeof Ctor &amp;&amp; &apos;function&apos; &amp;&amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object);&#125; Object.assign实现 123456789101112131415 Object.assign = function (target, ...source) &#123; if (arguments.length === 1) &#123; return target; &#125; source.forEach((ele,key)=&gt; &#123; for (var prop in ele) &#123; if (ele.hasOwnProperty(prop)) &#123; target[prop] = ele[prop]; &#125; &#125; &#125;); return target; &#125;` jQuery深度克隆 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, // 取第一个参数 如果存在就取，不存在 target = &#123;&#125;; target = arguments[ 0 ] || &#123;&#125;, i = 1, // 参数长度 length = arguments.length, // 是否为深度克隆 deep = false; // Handle a deep copy situation // 第一个参数 为布尔值的时候，将第一个参数的值付给deep; if ( typeof target === &quot;boolean&quot; ) &#123; deep = target; // Skip the boolean and the target // 进行第二个参数 target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== &quot;object&quot; &amp;&amp; !isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed // 如果只传递一个参数则扩展 jquery本身 if ( i === length ) &#123; console.log(this, 777) target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; console.log(name, 8888) src = target[ name ]; copy = options[ name ]; // console.log(copy, target); // Prevent never-ending loop // 防止永无止境的循环 if ( target === copy ) &#123; continue; &#125; // Recurse if we&apos;re merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don&apos;t bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭州旅游攻略]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%9D%AD%E5%B7%9E%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[第一天： 西湖： 苏堤春晓：贯穿西湖南北风景区的林荫大道；全长三公里，苏题栈下车 断桥残雪：断桥位于白堤东段；一说起平湖秋月的白堤到此为而断，称之为断桥；典故：白素贞许仙相会；断桥站下车； 平湖秋月：南宋时平湖秋月并无固定景址，而以泛舟湖上流览秋夜月景为胜。康熙三十八年，圣祖巡幸西湖，御书‘平湖秋月’匾额，从此，景点固定。现如今的平湖秋月观景点位于白堤西端，背倚孤山，面临外湖；有月亮最佳； 三潭印月：三潭印月是西湖十景之一，被誉为“西湖第一胜境”，三潭印月是西湖中最大的岛屿，风景秀丽、景色清幽，尤三潭印明月的景观享誉中外。主要景点“开网亭”“闲放台”“先贤祠”“迎翠轩”“花鸟厅”“我心相印亭”“曲桥”“九狮石”等 花港观鱼：花港观鱼是由花、港、鱼为特色的风景点。西湖十景之一。地处苏堤南段西侧。1964年二期扩建工程告竣后，占地面积达20公顷。全园分为红鱼池、牡丹园、花港、大草坪、密林地五个景区。与雷峰塔、净慈寺隔苏堤相望。 雷峰夕照：雷峰夕照，位于浙江省杭州市西湖湖南、净慈寺前的夕照山上，西湖十景之七，因晚霞镀塔，佛光普照而闻名 [1] 。雷峰塔建于五代（975），是吴越国王钱弘俶为庆祝黄妃得子而建，初名黄妃塔。 曲院风荷：曲院风荷位于西湖西侧，岳飞庙前面。南宋时，此有一座官家酿酒的作坊，取金沙涧的溪水造曲酒，闻名国内。附近的池塘种有菱荷，每当夏日风起，酒香荷香沁人心脾，因名“曲院风荷”。总占地面积12.65万平方米，总建筑面积268000万平米 双峰插云：双峰插云，指的是西湖南北两高峰奇红异多变的云景。南高峰在烟霞岭旁，北高峰在灵隐寺后，两峰之间层峦叠嶂，重谷回合，绵延二十余里，介从远处看去，则双峰对峙，近若几尺，兀突争雄，秀出群峰 孤山：主要景点有：放鹤亭、林和靖墓、西泠印社，玛瑙坡、一眼泉水、文澜阁、中山公园、清行宫、敬一书院、秋瑾墓、六一泉、苏曼殊墓园、半壁亭等；有诗云：孤山寺北贾亭西，水面初平云脚低；位置：白堤终点； 杨公提：西湖杨公堤位于西湖以西，堤上有六桥，自北向南名为：环璧、流金、卧龙、隐秀、景行、浚源。与东面的苏堤六桥前后呼应，合称为“西湖十二桥”。其中隐秀桥、景行桥可供游船通行。 钱江新城：每周的二五六晚上七点半和八点半各有一场灯光秀； 西溪国家湿地公园： 徒步，门票80；]]></content>
      <tags>
        <tag>浙江 杭州 旅游攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组方法总结]]></title>
    <url>%2F2018%2F11%2F09%2FArray-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组定义 javascript基础数据类型为： Number, String, Boolean, null, undefined, Object, Symbol;今天要总结的是：Array类型 javascript语言与其他语言不同的是，数组的每一项都可以保存任何类型的数据，数组大小可以动态调整； 创建数组方式构造函数创建 123let array = new Array(); // 创建空数组let colors = new Array(20); // length 值为20let names = new Array(&apos;liyingqi&apos;); // 创建一项值为liyingqi 字面量表示法 123let array = []; // 推荐这么用let colors = [2, 3,]; // 不要这样 IE8及更早版本 显示3项， 其他2项 每一项被undefined填充let array = [,,,,,]; // 不要这样 IE8及更早版本 显示6项 其他5项 每一项被undefined填充 练习一下 1234567let arr = [1, 2, undefined, null, &#123;x:1&#125;,f unction()&#123;&#125;];arr.length = 7; arr[6] = undefined;arr.length = 2;arr[2] = undefined; 检测数组 var arr = [1, 2]; 1: arr instanceof Array 123456if (arr instanceof Array) &#123; // 对数组执行某些操作&#125;if (arr.constructor === Array) &#123; // 对数组执行某些操作&#125; 缺点：不准确； 场景： 用iframe里面的方法来判断iframe外的类型是否为数组；因为 Array是挂在window上的； 2: Object.prototype.toString.call(arr); 123if (Object.prototype.toString.call(arr) === &apos;[object Array]&apos;) &#123; // 对数组执行某些操作&#125; call改变this指向当前数组，所以任何场景都可以使用 3: es5新增， Array.isArray(); // 返回值Boolean 12Array.isArray([]);// true 转换方法123[1,2,3].toString() // &apos;1,2,3&apos;[1,2,3].valueOf() // [1,2,3]alert([1,2,3]) //&apos;1,2,3&apos; 默认调用toString() 数组的方法 方法 是否改变原数组 数组返回值 作用 push Y 数组长度 数组末尾入栈 pop Y 原数组最后一项 数组末尾出栈 shift Y 原数组第一项 数组前出栈 unshift Y 数组长度 数组前入栈 reverse Y 反序后的新数组 将数组反序 sort Y 排序后的数组 数组排序 splice Y 删除的数组 数组拼接 join N 字符串 将数组转化为字符串 concat N 合并后的数组 数组拼接 isArray N true或false 数组判断 filter N 符合规则的数组 过滤数组 forEach N 处理后的数组 遍历数组 map N 处理后的数组 数组映射 some N true或false 数组判断 every N true或false 数组判断 some N true或false 数组判断 indexOf N 数组下标或者是-1 数组下标 lastIndexOf N 数组下标或者是-1 数组下标 reduce N 数组下标或者是-1 数组下标 reduceRight N 数组下标或者是-1 数组下标 数组方法push unshift 返回数组长度 pop shift 返回移除的项 堆栈概念 堆，栈：堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。 栈：（stack）又名堆栈，其限制是允许在表的一端进行插入和删除运算，这一端称为栈顶，相对的把另一端称为栈底。 栈就是一个桶，后放进去的先拿出来，（先进后出） ①堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。 ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来。（后进先出） ③队列只能在队头做删除操作,在队尾做插入操作.而栈只能在栈顶做插入和删除操作。（先进先出） javascript 数组，具体来说，数组可以表现的和栈一样，栈是LIFO(last-in-first-out)先进后出， 只需在栈顶插入和移除数据，队列(FIFO)（first-in-first-out）先进先出 用数组实现栈方法 （push, pop）只能在栈顶操作1234567var colors = new Array();var count = colors.push(&apos;red&apos;, &apos;blue&apos;); // 入栈两项ount = colors.push(&apos;black&apos;); // 栈顶插入一项console.log(count); // 3var item = colors.pop(); // 取最后一项 队列方法（push， shift）FIFO 1234567var colors = new Array();var count = colors.push(&apos;red&apos;, &apos;blue&apos;); // 入栈两项var count = colors.push(&apos;black&apos;); // 插入另一项console.log(count); // 3count = colors.shift(&apos;red&apos;, &apos;blue&apos;);console.log(count); // 取得第一项 扩展：用两个栈实现队列 s1是入栈的，s2是出栈的。 入队列：直接压入s1即可 出队列：如果s2不为空，把s2中的栈顶元素直接弹出；否则，把s1的所有元素全部弹出压入s2中，再弹出s2的栈顶元素 换一种思维就是只用push,pop方法实现队列功能，用两个数组实现队列功能，只能用pop,push（soeasy） 操作方法concat方法这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新创建的数组。在没有给concat传参数的情况下，他只是复制当前数组并且返回新副本，如果传递对个数组，这个方法会将数组中的每一项添加到副本中，（对于数组来说只是浅拷贝），如果不是数组这些值只是简单的添加到副本末尾； 1234var colors = [1, 2, 3];var result = colors.concat(1, [6, 7], &#123;name: &quot;value&quot;&#125;);console.log(result); // [1, 2, 3, 1, 6, 7, &#123;name: &quot;value&quot;&#125;]console.log(colors); // [1, 2, 3]; slice 截取数组他能够基于当前数组中的一个，或者多个项创建一个新数组。slice() 方法可以接受一个或者两个参数，返回项的起始和结束位置，在只有一个参数的情况下，返回从该参数指定位置开始，到当前数组末尾的所有项。如果有两个参数，该方法返回起始位置和结束位置之间的所有项，但是不包括结束位置项；slice()方法不会影响原数组； 12345678var colors = [&apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;];var colors2 = colors.slice(1);var colors3 = colors.slice(1, 3);var colors4 = colors.slice(1, -1);console.log(colors2); // [&quot;w&quot;, &quot;e&quot;, &quot;r&quot;]console.log(colors3); // [&quot;w&quot;, &quot;e&quot;]console.log(colors4); // [&quot;w&quot;, &quot;e&quot;] 注意: 如果slice()方法的参数中有一个为负数,则用数组的长度加上该数来确定相应位置，在一个包含4项的数组上调用slice(-3, -1);与调用slice(1, 3)得到的结果相同如colors3,如果结束位置小于起始位置则返回一个空数组； splice 数组拼接，改变原数组删除：可以删除任意数量的项，只需要指定两个参数：要删除第一项的位置和要删除的项数，例如：splice(0, 2);删除数组中的前两项； 插入：可以向指定位置插入任意数量的项，需要3个参数：起始位置，要删除的项数（0），要插入的项，若果要传多个项，可以传入第4，5，6.。。任意多各项， 替换：在插入的基础上，第二个参数不为0,就为替换】； 返回值：splice()方法始终会返回一个数组，该数组包含从原始数组中删除的项（如果没有删除任何项，则返回空数组） 12345678var colors = [&quot;q&quot;, &quot;w&quot;, &quot;e&quot;, &quot;r&quot;];var removed = colors.splice(0, 1);console.log(colors); // [&quot;w&quot;, &quot;e&quot;, &quot;r&quot;]console.log(removed); // [&quot;q&quot;] 返回删除的项removed = colors.splice(1, 0, &apos;liyingqi&apos;);console.log(colors); // [&apos;w&apos;,&apos;liyingqi&apos;, &apos;e&apos;, &apos;r&apos;] // 删除项为0， 在索引前面插入console.log(removed); // 返回空数组 位置方法es5为数组实例添加了两个位置方法：indexOf 和 lastIndexOf() 这两个方法都接受两个参数：要查找的项和查找起点位置的索引；两个方法都可以接受可选的第二个参数 区别在于：indexOf()会从该参数的指定位置向后搜索，lastIndexOf()会从改参数指定位置向前搜索； 返回值：返回要查找的项在数组中的位置，或者在没有找到的情况下，返回-1；要查找的项必须严格相等； 123456789101112var arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];var index = arr.indexOf(4);var lastIndex = arr.lastIndexOf(4);console.log(index); // 3console.log(lastIndex); // 5index = arr.indexOf(4, 4);lastIndex = arr.lastIndexOf(4, 4);console.log(index); // 5 从索引位置向后搜索console.log(lastIndex); // 3 从索引位置向前搜索 归并方法 es5 新增两个归并数组的方法：reduce()和reduceRight(),这两个方法都会迭代数组的所有项。然后构建一个最终返回的值。其中reduce()方法是从数组的第一项开始的遍历到最后， reduceRight()从数组最后一项开始，向前遍历到第一项； arr.reduce(callback,[initialValue]) callback （执行数组中每个值的函数，包含四个参数） previousValue （第一项的值或者上一次叠加的结果值，或者是提供的初始值（initialValue）） currentValue （数组中当前被处理的元素） index （当前元素在数组中的索引） array （数组本身） initialValue （作为第一次调用 callback 的第一个参数，可以控制返回值的格式） reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右），最终计算为一个值。 12345678910111213var arr = [1, 2, 3, 4, 5];sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); //输出的是第一项的值或上一次叠加的结果，正在被处理的元素，正在被处理的元素的索引值 return prev + cur;&#125;)console.log(arr, sum); //输入数组本身和最后的结果// 结果1 2 1 3 3 26 4 310 5 4[1, 2, 3, 4, 5] 15 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;，10); // 结果：35，变成了初始值和数组的和 reduce() 可以作为一个高阶函数，用于函数的 compose。 什么是compose：javascript函数式编程中另外一个很重要的函数compose，compose函数的作用就是组合函数的，将函数串联起来执行，将多个函数组合起来，一个函数的输出结果是另一个函数的输入参数，一旦第一个函数开始执行，就会像多米诺骨牌一样推导执行了。 redux compose源码 123456789101112131415161718192021function compose() &#123; for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key &lt; _len; _key++) &#123; funcs[_key] = arguments[_key]; &#125; if (funcs.length === 0) &#123; return function (arg) &#123; return arg; &#125;; &#125; if (funcs.length === 1) &#123; return funcs[0]; &#125; console.log(arguments); return funcs.reduce(function (a, b) &#123; return function () &#123; return a(b.apply(void 0, arguments)); &#125;; &#125;);&#125; lodash的思路，用迭代实现的，我就把它的源代码贴过来看一下 1234567891011121314151617181920var flow = function(funcs) &#123; var length = funcs.length var index = length while (index--) &#123; if (typeof funcs[index] !== &apos;function&apos;) &#123; throw new TypeError(&apos;Expected a function&apos;); &#125; &#125; return function(...args) &#123; var index = 0 var result = length ? funcs[index].apply(this, args) : args[0] while (++index &lt; length) &#123; result = funcs[index].call(this, result) &#125; return result &#125;&#125;var flowRight = function(funcs) &#123; return flow(funcs.reverse())&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数组定义 数组方法 堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由实现方式及页面跳转]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[a标签的target属性 (1). 默认_self属性在当前框架，或者游览器中打开窗口 (2). 有_blank新的游览器窗口中打开，不可window.history.back() || go(n), forward(); 相当于window.location.reload(); (3). 有_top，场景当出现框架套框架的时候，在底层框架调用_top会导致在整个游览器窗口中打开被链接文档； (4). 有_parent，场景如上，在父框架中打开被链接文档。 (5). 场景：当搜索职位，web前端简历时，在搜索结果页出现一系列的列表，想要点击每一个列表进入简历详情页，并且这些简历详情页只展示在一个新增窗口上; 123456 &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;index1.html&quot; target=&quot;view_window&quot;&gt;Chapter 0&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index2.html&quot; target=&quot;view_window&quot;&gt;Chapter 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index3.html&quot; target=&quot;view_window&quot;&gt;Chapter 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index4.html&quot; target=&quot;view_window&quot;&gt;Chapter 3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 当用户第一次选择内容列表中的某个链接时，浏览器将打开一个新的窗口，将它标记为 &quot;view_window&quot;，然后在其中显示希望显示的文档内容。如果用户从这个内容列表中选择另一个链接，且这个 &quot;view_window&quot; 仍处于打开状态，浏览器就会再次将选定的文档载入那个窗口，取代刚才的那些文档。 (6). 在框架中打开窗口 不用打开一个完整的浏览器窗口，使用 target 更通常的方法是在一个 显示中将超链接内容定向到一个或者多个框架中。可以将这个内容列表放入一个带有两个框架的文档的其中一个框架中，并用这个相邻的框架来显示选定的文档： w3c, 实例结果页就是用这种思想 // 对框架不了解的同学可以，去框架模块看一下(无body), 例子 https://github.com/lyqbetter/blog-demo.git 里面的demo1; javascript 跳转页面window.location.href = url; 在当前窗口跳转页面 window.reload(); //重新刷新页面 window.open(url); // 在新窗口打开网站 前端路由实现方式 提起路由先说一下window.history这个对象吧： 浏览器(窗口 画重点)有一个history对象，用来保存浏览历史 Window.history是一个只读属性，用来获取History 对象的引用，History 对象提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口。 history: 返回值 scrollRestoration： auto; history.scrollRestoration。它提供两个值，auto，作为它的默认值，可以像你所见的大多数情况一样工作，另一个manual，意味着作为一个开发者你拥有了自主掌控任何所需的scroll改变，当用户循环往复于app的history中。如果需要，你可以跟踪scroll的位置轨迹 length: Internet Explorer和Opera从0开始，而Firefox、Chrome和Safari从1开始。 属性声明了浏览器历史列表中的元素数量; state: 状态对象 1234window.history.back(); // 当前窗口游览器回话记录回退window.history.forward(); // 前进window.history.go(n); // n可正可负， 负回退，正前进//如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是默默的失败 路由就是指随着浏览器地址栏的变化，展示给用户的页面也不相同。传统的网页根据用户访问的不同的地址，浏览器从服务器获取对应页面的内容展示给用户。这样造成服务器压力比较大，而且用户访问速度也比较慢。在这种场景下，出现了单页应用。单页应用，就是只有一个页面，用户访问一个网址，服务器返回的页面始终只有一个，不管用户改变了浏览器地址栏的内容或者在页面内发生了跳转，服务器不会重新返回新的页面，而是通过相应的js操作来实现页面的更改。而地址栏内容的改变，显示不同的页面，实现的手段就是前端路由 第一种 HTML5 History两个新增的API：history.pushState 和 history.replaceState，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。 history.pushState方法由于添加会话历史，接受三个参数，依次为： state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。 title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。 url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。(为空当前url) history.replaceState() history.replaceState方法的参数与pushState方法一模一样，区别是它修改浏览历史中当前纪录。 popstate 事件 每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。 需要注意的是，仅仅调用pushState方法或replaceState方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用JavaScript调用back、forward、go方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。 123window.addEventListener(&apos;popstate&apos;, (e)=&gt; &#123; console.log(e);&#125;, false); 第二种Hash就是url 中看到 # ,我们需要一个根据监听哈希变化触发的事件( hashchange) 事件。我们用 window.location.hash 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。 可以为hash的改变添加监听事件： 123window.addEventListener(&apos;hashchange&apos;, (e)=&gt; &#123; console.log(e);&#125;, false); 总结 优点： 从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。 前端路由的优点有很多，比如页面持久性，像大部分音乐网站，你都可以在播放歌曲的同时，跳转到别的页面而音乐没有中断，再比如前后端彻底分离。 开发一个前端路由，主要考虑到页面的可插拔、页面的生命周期、内存管理等。 缺点：使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存 单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置;(scrollRestoration兼容性不好)；]]></content>
      <tags>
        <tag>路由 跳转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端click延迟及zepto的穿透现象]]></title>
    <url>%2F2018%2F10%2F05%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFclick%E5%BB%B6%E8%BF%9F%E5%8F%8Azepto%E7%9A%84%E7%A9%BF%E9%80%8F%E7%8E%B0%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[穿透现象与click的延迟解决方法是分不开的，若要了解穿透现象，需要先了解click延迟的解决原理。 移动端click事件300ms的延迟现象的原因：在最早iphone的safar浏览器中，为了实现触屏中双击放大效果，当用户点击屏幕时后会判断在300ms内是否有第二次点击，如果有，就理解成双击，若没有就是单击, 就会触发click事件. 当你点击移动设备的屏幕时, 可以分解成多个事件，顺序依次为：touchstart — touchmove — touchend — click, 这些事件是按顺序依次触发的 12345678910111213var oLi = document.getElementsByTagName(&apos;li&apos;)[0];oLi.addEventListener(&apos;click&apos;, ()=&gt; &#123; console.log(&apos;click&apos;);&#125;);oLi.addEventListener(&apos;touchend&apos;, ()=&gt; &#123; console.log(&apos;touchend&apos;);&#125;);oLi.addEventListener(&apos;touchmove&apos;, ()=&gt; &#123; console.log(&apos;touchmove按下鼠标，移动，触发&apos;);&#125;);oLi.addEventListener(&apos;touchstart&apos;, ()=&gt; &#123; console.log(&apos;touchstart&apos;);&#125;); 控制台输出： 12345678touchstarttouchendclick。。。。touchstarttouchmove按下鼠标，移动，触发touchend(没有click) 解决延迟的思路：touchstart touchend是没有延迟的，可以在touchend时触发用户想要在click时触发的事件. zepto 解决click延迟的原理：自定义tap事件，当用户点击元素时，touchend事件先发生, 当touchend事件冒泡到document时触发目标元素绑定的tap事件, 12345678910var oLi = document.getElementsByTagName(&apos;li&apos;)[0];document.addEventListener(&apos;touchend&apos;, function (e) &#123; // 生成事件 var tap = new Event(&apos;tap&apos;); // 触发事件 e.target.dispatchEvent(tap);&#125;);oLi.addEventListener(&apos;tap&apos;, function () &#123; // 处理点击事件&#125;); zepto中的点击穿透问题zepto中的 tap 通过兼听绑定在 document 上的 touch 事件来完成 tap 事件的模拟的，是通过事件冒泡实现的。在点击完成时（touchstart / touchend）的 tap 事件需要冒泡到 document 上才会触发。而在冒泡到 document 之前，手指接触和离开屏幕（touchstart / touchend）是会触发 click 事件的。 因为 click 事件有延迟（大概是300ms，为了实现safari的双击事件的设计），所以在执行完 tap 事件之后，弹出层立马就隐藏了，此时 click 事件还在延迟的 300ms 之中。当 300ms 到来的时候，click 到的其实是隐藏元素下方的元素。 如果正下方的元素有绑定 click 事件，此时便会触发，如果没有绑定 click 事件的话就当没发生。如果正下方的是 input 输入框（或是 select / radio / checkbox），点击默认 focus 而弹出输入键盘，也就出现了上面的“点透”现象。 穿透的解决办法 由于 click 事件的滞后性，在这段时间内原来点击的元素消失了，于是便“穿透”了。因此我们顺着这个思路就想到，可以给元素的消失做一个fade效果，类似jQuery里的fadeOut，并设置动画duration大于300ms，这样当延迟的 click 触发时，就不会“穿透”到下方的元素了。 同样的道理，不用延时动画，我们还可以动态地在触摸位置生成一个透明的元素，这样当上层元素消失而延迟的click来到时，它点击到的是那个透明的元素，也不会“穿透”到底下。在一定的timeout后再将生成的透明元素移 pointer-events是CSS3中的属性，它有很多取值，有用的主要是auto和none，其他属性值为SVG服务 12 auto 效果和没有定义 pointer-events 属性相同，鼠标不会穿透当前层。none 元素不再是鼠标事件的目标，鼠标不再监听当前层而去监听下面的层中的元素。但是如果它的子元素设置了pointer-events为其它值，比如auto，鼠标还是会监听这个子元素的。 fastclick使用fastclick库，其实现思路是，取消 click 事件（参看源码 164-173 行），用 touchend 模拟快速点击行为（参看源码 521-610 行）。 1FastClick.attach(document.body); 移动端兼容问题研究javascript事件机制详解（涉及移动兼容）;]]></content>
      <tags>
        <tag>移动端点击事件 延迟 zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOCTYPE 兼容模式和标准模式]]></title>
    <url>%2F2018%2F09%2F23%2FDOCTYPE-%E5%85%BC%E5%AE%B9%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式(quirks mode)。 游览器解析模式 Standards(标准)模式：遵循最新标准。 Quirks（怪癖/兼容）模式：帮助处理所有奇怪的渲染和非浏览器兼容及不符合标准的网页。 Almost Standards（近似标准）模式：针对标准的某个老版本设计的网页。 触发兼容模式 浏览器会根据 DOCTYPE 声明进入正确的呈现模式，但有时候它也并不那么听话，以下情况会触发兼容模式： 未指定URL或者指定的是一个相对的路径（而不是完全限定的Internet地址），大多数浏览器会进入兼容模式而不管当初声明的是什么模式 没有使用或格式错误的DOCTYPE。浏览器如果不能识别一个错误的DOCTYPE，那么也会强制进入兼容模式，建议直接复制拷贝DOCTYPE声明而不是亲自输入。 过渡型的DOCTYPE不同浏览器在处理过渡型DOCTYPE时是有差异的。有可能进入标准模式，也有可能进入兼容模式。 DOCTYPE声明告诉类似的代码校验器或者浏览器应该按照什么规则集解析文档，这些“规则”就是W3C发表的文档类型定义（DTD）中包含的规则文档类型定义（DTD）DTD中包含了一系列标记、属性，用于标记Web文档中能出现哪些元素和元素之间的包含关系。如果没有指定有效的DOCTYPE声明，浏览器可能会使用内置的默认DTD。你也可以自定义DTD，但一般不推荐这样。常见的DOCTYPE声明如下12345678910111213141516171819202122&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;HTML 4.01 Transitional：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;HTML 4.01 Frameset：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;XHTML 1.0 Strict：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;XHTML 1.0 Transitional：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;XHTML 1.0 Frameset：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;XHTML 1.1：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;XHTML 1.1 plus MathML plus SVG：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN&quot; &quot;http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd&quot;&gt; 组成部分12语法：&lt;!DOCTYPE 根元素 可用性 &quot;注册//组织//类型 标签 定义//语言&quot; &quot;URL&quot;&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 根元素指定 DTD 中声明的顶级元素类型，这与声明的 SGML 文档类型相对应，默认HTML 。 可用性指定正式公开标识符(FPI)是可公开访问的对象还是系统资源。 默认 PUBLIC 可公开访问的对象。 SYSTEM 系统资源，如本地文件或 URL。 注册指定组织是否由国际标准化组织(ISO)注册。默认 + ，组织名称已注册。 - 组织名称未注册，Internet 工程任务组(IETF)和万维网协会(W3C)并非注册的 ISO 组织。 组织指定表明负责由 !DOCTYPE 声明引用的 DTD 的创建和维护的团体或组织的名称，即 OwnderID。 IETF 或 W3C。 类型指定公开文本类，即所引用的对象类型。默认 DTD。 标签指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号。默认 HTML 。 定义指定文档类型定义。 Frameset 框架集文档。 Strict 排除所有 W3C 专家希望逐步淘汰的代表性属性和元素，因为样式表已经很完善了。Transitional 包含除 frameSet 元素的全部内容。 语言指定公开文本语言，即用于创建所引用对象的自然语言编码系统。该语言定义已编写为 ISO 639 语言代码(大写两个字母)。 默认 EN。 URL指定所引用对象的位置。 怪异Quirks模式是什么，它和标准Standards模式有什么区别？从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。 在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？ 在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。 区别：总体会有布局、样式解析和脚本执行三个方面的区别。 盒模型 ：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。 设置行内元素的高宽 ：在Standards模式下，给等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。 设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。]]></content>
      <tags>
        <tag>ie 兼容模式 标准模式 盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frameset框架]]></title>
    <url>%2F2018%2F09%2F11%2Fframeset%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[HTML iframe 和 frameset 的区别 iframe 和 frameset 都用于html页面的框架布局。 (1). iframe标签：iframe 是个内联框架，是在页面里生成个内部框架。 (2). frameset 标签：frameset 定义一个框架集，包含多个子框架，每个框架都有独立的文档。 iframe 标签 iframe 是个内联框架，是在页面里生成个内部框架。 frameborder {int}：是否显示框架的边框； src {URL}：指定一个资源(如网页、图片)的uri； scrolling {boolean}：是否显示框架的滚动条； width {int}：定义iframe的宽度； height {int}：定义iframe的高度； 应用场景： 重复嵌套页面，一个页面需要重复利用 frameset 标签 frameset 定义一个框架集，包含多个框架，每个框架都有独立的文档。 123456789101112// 没有body 注意， 有的话不渲染框架&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; &lt;frameset &gt; &lt;frame src=a.htm /&gt; &lt;frame src=b.htm /&gt; &lt;noframes&gt;&lt;/noframes&gt; &lt;/frameset&gt;&lt;/html&gt; ：子框架 ：浏览器不支持此框架的时，显示的内容。 frameset属性： rows ：表示子框架按行的样式布局。以2个子框架为例：rows=”30%,“ ，表示第一个框架占整个页面30%的高度，第二个占剩下的； cols ：表示子框架按列的样式布局。以2个子框架为例：cols=”30%,“ ，表示第一个框架占整个页面30%的长度，第二个占剩下的； noresize: “noresize”表示不调整子框架的范围。 frame 属性： src ：指向一个资源(如页面、图片等)的URI； name ：指定框架的名称，以便进行框架间的操作。 参照示例代码，frm1更改frm2的子集指向的页面：window.parent.frames[“frm2”].location.href = ‘b.htm’ 应用场景：1 后台页面的管理，左边显示 菜单，右边框架 显示详细页面。批量游览简历 https://lpt.liepin.com 本文参考 https://www.cnblogs.com/polk6/archive/2013/05/24/3097430.html]]></content>
      <tags>
        <tag>frameset iframe frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F08%2Fhexo%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 图片转 base64 url]]></content>
  </entry>
  <entry>
    <title><![CDATA[长列表性能优化]]></title>
    <url>%2F2018%2F07%2F02%2F%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端的业务开发中会遇到一些无法使用分页方式来加载的列表，我们一般把这种列表叫做长列表。在本篇文章中，我们把长列表定义成数据长度大于 1000 条，并且不能使用分页的形式来展示的列表。 研究的意义从哪几方面研究 完整渲染的长列表是否有优化的可能？优化的极限在什么位置？ 如果使用非完整的渲染长列表，有哪些方案以及具体的实现思路。 完整渲染长列表如果长列表不去做任何优化，一次完整渲染出来，到底需要多长时间呢？那么首先要先了解创建所有的 HTMLElement 并添加到 Document 中的时间消耗，因为业务中会混杂一些其他的代码，你的业务的性能不会比这个时间快。对浏览器创建元素的性能有大概的了解，才能知道长列表的优化极限在哪里。 我们可以写一个简单的方法来测试这个性能： 12345678910111213var createElements = function(count) &#123; var start = new Date(); for (var i = 0; i &lt; count; i++) &#123; var element = document.createElement(&apos;div&apos;); element.appendChild(document.createTextNode(&apos;&apos; + i)); document.body.appendChild(element); &#125; setTimeout(function() &#123; alert(new Date() - start); &#125;, 0);&#125;; DOM 的操作会引起浏览器的 重排重绘（详情请见重排重绘），如果浏览器的 reflow 执行的时间远大于代码执行时间，会造成你时间计算完成之后，浏览器仍然在卡顿。统计的时间应该是从『开始创建元素』到『可以进行响应』的时间，所以一个合理的做法是把计算放在 setTimeout(function() {}, 0) 中。setTimeout() 中的 callback 会被推迟到浏览器主线程 reflow 结束后才执行，这个时间和 Chrome Devtools 下的 Profile 的时间基本吻合，可以信任这个时间作为渲染时间 当然，上面写法很low, 一般人写不出来 。。。。 ####尝试使用不同的 DOM API有两种方法 createDocumentFragment 文档碎片 innerHTML 字符串模板 使用 DocumentFragment 的方法如下 在线编写demo： 123456789101112131415function createElements(count) &#123; const start = new Date(); let fragment = document.createDocumentFragment(); while(count--) &#123; let ele = document.createElement(&apos;div&apos;); ele.appendChild(document.createNoteText(&apos;&apos; + count)); fragment.appendChild(ele); &#125; document.body.appendChild(fragment); setTimeout(()=&gt; &#123; alert(new Date() - start); &#125;, 0)&#125;createElements(1000); 使用 innerHTML 的方法如下 在线编写demo： 12345678910111213var createElementsWithHTML = function(count) &#123; var start = new Date(); var str = &apos;&apos;; for (var i = 0; i &lt; count; i++) &#123; str = &apos;&lt;div&gt;&apos; + i + &apos;&lt;/div&gt;&apos;; &#125; var element = document.createElement(&apos;div&apos;); element.innerHTML = str; document.body.appendChild(element); setTimeout(function() &#123; alert(new Date() - start); &#125;, 0);&#125;; 数据统计 测试代码的计算的时间每次执行都会有一些误差，表格中的数据使用的是进行 10 次测试的平均值： 非渲染长列表 从上面的测试结果中可以看到，创建 10000 个节点就需要 500ms+，实际业务中的列表每个节点都需要 20 个左右的节点。那么，500ms 也仅能渲染 500 个左右的列表项。 所以完整渲染的长列表基本上很难达到业务上的要求的，非完整渲染的长列表一般有两种方式： 懒渲染：这个就是常见的无限滚动的，每次只渲染一部分（比如 10 条），等剩余部分滚动到可见区域，就再渲染另一部分。 可视区域渲染：只渲染可见部分，不可见部分不渲染。 懒渲染 懒渲染就是大家平常说的无限滚动，指的就是在滚动到页面底部的时候，再去加载剩余的数据。这是一种前后端共同优化的方式，后端一次加载比较少的数据可以节省流量，前端首次渲染更少的数据速度会更快。这种优化要求产品方必须接受这种形式的列表，否则就无法使用这种方式优化。 实现的思路非常简单：监听父元素的 scroll 事件（一般是 window），通过父元素的 scrollTop 判断是否到了页面是否到了页面底部，如果到了页面底部，就加载更多的数据。 可视区域渲染 可视区域渲染指的是只渲染可视区域的列表项，非可见区域的完全不渲染，在滚动条滚动时动态更新列表项。可视区域渲染适合下面这种场景： 每个数据的展现形式的高度需要一致（非必须，但是最小高度需要确定）。 产品设计上，一次需要加载的数据量比较大「1000条以上」。 产品设计上，滚动条需要挂载在一个固定高度的区域（在 window 上也可以，但是需要整个区域都只显示这个列表）。 本文使用 Vue 实现了一个例子来说明这种类型的列表该如何实现，这个例子做了以下三个设定： 列表的高度为 400px。 列表中的每个元素的高度是 30px。 一次加载 10000 条数据。 点击此处看demo]]></content>
      <tags>
        <tag>web优化 长列表</tag>
      </tags>
  </entry>
</search>
