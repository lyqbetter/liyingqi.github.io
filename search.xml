<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[游览器结构]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%B8%B8%E8%A7%88%E5%99%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端模块化]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>AMD / CMD / es6模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包原理]]></title>
    <url>%2F2019%2F02%2F26%2Fwebpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2019%2F01%2F05%2FDOM%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络部分]]></title>
    <url>%2F2019%2F01%2F02%2F%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>http https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb mongoose]]></title>
    <url>%2F2018%2F12%2F02%2Fmongodb-mongoose%2F</url>
    <content type="text"><![CDATA[mongodb 介绍 mongoDB与一些关系型数据库相比，它更显得轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。同时它也是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储。由c++语言编写，是一个分布式文件存储的开源NoSQL数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。mongoDB旨在为web应用提供可扩展的高性能数据存储解决方案 mongoDB将数据存储为一个文档，数据结构由键值对组成。mongoDB文档类似于JSON对象，字段值可以包含其他文档、数组及文档数组。 分布式数据库系统通常使用较小的计算机系统，每台计算机可单独放在一个地方，每台计算机中都可能有DBMS的一份完整拷贝副本，或者部分拷贝副本，并具有自己局部的数据库，位于不同地点的许多计算机通过网络互相连接，共同组成一个完整的、全局的逻辑上集中、物理上分布的大型数据库 123// mac 下载brew updatebrew install mongodb 启动 从命令行启动 执行mongod，启动MongoDB服务器，mongod有很多可配置的启动选项，可以使用mongod –help查看所有选项 1mongod --config /usr/local/etc/mongod.conf 后台启动 –dbpath： 指定数据目录，默认是/data/db下，每个mongod进程都需要独立的数据目录，加入有3个mongod实例，就必须要有3个独立的数据目录。当mongod启动时，会在数据目录中创建mongod.lock文件。这个文件用于防止其他mongod进程使用该数据目录。若当有一个mongd启动后，再启动另一个mongod时，若再使用刚刚已经启动mongod的目录，那么会报错： 12017-07-06T16:03:09.703+0800 I STORAGE [initandlisten] exception in initAndListen: 98 Unable to lock file: mongodb/0706/mongod.lock Resource temporarily unavailable. Is a mongod instance initAndListenready running?, terminating –port： 指定服务器监听的端口号。默认端口号为27017，要是运行多个mongod，必须指定不同的端口号 若有一个27017的端口已经使用了，那么如果启动第二个mongod的时候，若还指定27017的话，会报错： mongoosemongoose是mongoDB的一个对象模型工具，是基于node-mongodb-native开发的mongoDB的nodejs驱动，可以在异步的环境下执行。同时它也是针对mongoDB操作的一个对象模型库，封装了mongoDB对文档的一些增删改查等常用方法，让nodejs操作mongoDB数据库变得更加容易。 model.js 1234567891011121314151617181920212223242526272829303132333435// npm install mongooseconst mongoose = require(&apos;mongoose&apos;)// 链接mongo 并且使用liyingiq这个集合const DB_URL = &apos;mongodb://localhost:27017/liyingqi-chat&apos;// 连接数据库mongoose.connect(DB_URL)// 数据模型const models = &#123; user:&#123; &apos;user&apos;:&#123;type:String, &apos;required&apos;:true&#125;, &apos;pwd&apos;:&#123;type:String, &apos;required&apos;:true&#125;, &apos;type&apos;:&#123;&apos;type&apos;:String, &apos;required&apos;:true&#125;, //头像 &apos;avatar&apos;:&#123;&apos;type&apos;:String&#125;, // 个人简介或者职位简介 &apos;desc&apos;:&#123;&apos;type&apos;:String&#125;, // 职位名 &apos;title&apos;:&#123;&apos;type&apos;:String&#125;, // 如果你是boss 还有两个字段 &apos;company&apos;:&#123;&apos;type&apos;:String&#125;, &apos;money&apos;:&#123;&apos;type&apos;:String&#125; &#125;&#125;for(let m in models)&#123; // 建表 存储数据 mongoose.model(m, new mongoose.Schema(models[m]))&#125;// 导出module.exports = &#123; getModel:function(name)&#123; return mongoose.model(name) &#125;&#125; server.js 12345678910111213141516171819let models = require(&apos;./model&apos;);let User = models.getModel(&apos;user&apos;);// 增加User.create(&#123;user: &apos;liyingqi&apos;&#125;, function (err, doc) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(doc); &#125;&#125;);// 删除User.remove(&#123;user: &apos;liyingqi&apos;&#125;, function (error) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;用户删除成功&quot;) &#125;&#125;); 查询数据 find 模糊查找，查找所有 123456789//查询所有密码为“123456”的文档记录userMode.find(&#123;&quot;pwd&quot;: &apos;123456&apos;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;密码为123456的个数：&quot;,docs.length) console.error(&quot;所有文档如下：\n&quot;,docs) &#125;&#125;); 日志信息 12345678910111213141516171819202122密码为1234567的个数： 4所有文档如下： [ &#123; _id: 587d7b4aa51c535f09b8cc41, name: &apos;tiny&apos;, password: &apos;1234567&apos;, age: 14, __v: 0 &#125;, &#123; _id: 587d7b56a51c535f09b8cc42, name: &apos;tinyjoy1&apos;, password: &apos;1234567&apos;, age: 18, __v: 0 &#125;, &#123; _id: 587d7b71a51c535f09b8cc44, name: &apos;tinyjoy3&apos;, password: &apos;1234567&apos;, age: 60, __v: 0 &#125;, &#123; _id: 587d7e2463260b78550e8366, name: &apos;tinyjoy2&apos;, password: &apos;1234567&apos;, age: 60, __v: 0 &#125; ] 属性过滤 find(Conditions,field,callback); 12345678// 查询密码为“1234567”的所有记录，返回文档记录只包含一个键值nameUser.find(&#123;&quot;password&quot;: userInfo.password&#125;,&#123;name:&quot;liyingqi&quot;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;查询结果：&quot;,docs) &#125;&#125;); 日志信息 1234查询结果： [ &#123; _id: 587d7b4aa51c535f09b8cc41, name: &apos;tiny&apos; &#125;,&#123; _id: 587d7b56a51c535f09b8cc42, name: &apos;tinyjoy1&apos; &#125;,&#123; _id: 587d7b71a51c535f09b8cc44, name: &apos;tinyjoy3&apos; &#125;,&#123; _id: 587d7e2463260b78550e8366, name: &apos;tinyjoy2&apos; &#125; ] findOne: 与find相同，但只返回单个文档，也就说当查询到即一个符合条件的数据时，将停止继续查询，并返回查询结果。findOne方法，只返回第一个符合条件的文档数据。 单条数据 findOne(Conditions,callback); 12345678// 查询密码为123456的一条记录 User.findOne(&#123;&quot;password&quot;: &apos;123456&apos;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;查询结果：&quot;,docs) &#125; &#125;); 日志信息 12345查询结果： &#123; _id: 587d7b4aa51c535f09b8cc41, name: &apos;tiny&apos;, password: &apos;1234567&apos;, age: 14, __v: 0 &#125; findById 与findOne相同，但它只接收文档的_id作为参数，返回单个文档。单条数据 findById(_id, callback);条件查询 “$lt”(小于)，”$lte”(小于等于),”$gt”(大于)，”$gte”(大于等于)，”$ne”(不等于)，”$in”(可单值和多个值的匹配)，”$or”(查询多个键值的任意给定值)，”$exists”(表示是否存在的意思)”$all”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//查询年龄小于18的所有记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$lt&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;查询结果：&quot;, doc) &#125;&#125;);//查询年龄小于等于18的所有记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$lte&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;查询结果：&quot;, doc) &#125;&#125;);//查询年龄不等于18的所有文档记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$ne&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;年龄不等于18的查询结果：&quot;, doc) &#125;&#125;);//查询年龄大于18的所有文档记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$gt&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;年龄大于18的查询结果：&quot;, doc) &#125;&#125;);//查询年龄大于等于18的所有文档记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$gte&quot;: 18&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;年龄大于等于18的查询结果：&quot;, doc) &#125;&#125;);//查询年龄大于等于18小于等于60所有文档记录userMode.find(&#123;&quot;age&quot;: &#123;&quot;$gte&quot;: 18, &quot;$lte&quot;: 60&#125;&#125;, function (error, doc) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;年龄大于等于18小于等于60查询结果：&quot;, doc) &#125;&#125;); “$in”和$nin’ 1234567891011121314151617181920212223242526//查询年龄等于18的所有记录userMode.find(&#123;age:&#123;$in: 18&#125;&#125;,function (error,doc) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;年龄为18的查询结果：&quot;,doc) &#125;&#125;); //查询年龄等于18和19的所有记录userMode.find(&#123;age:&#123;&quot;$in&quot;:[18,19]&#125;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;年龄为18和19的查询结果：&quot;,docs) &#125;&#125;); //查询年龄不等于18和19的所有记录userMode.find(&#123;age:&#123;&quot;$nin&quot;:[18,19]&#125;&#125;,function (error,docs) &#123; if (error)&#123; console.error(error); &#125;else&#123; console.error(&quot;年龄不等于18和19的查询结果：&quot;,docs) &#125;&#125;); $Or或查询： 1234567891011121314151617//查询年龄等于18或者名字为tiny所有记录userMode.find(&#123;&quot;$or&quot;: [&#123;&quot;name&quot;: &quot;tiny&quot;&#125;, &#123;&quot;age&quot;: 18&#125;]&#125;, function (error, docs) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;$or查询结果：&quot;, docs) &#125;&#125;); //查询年龄不等于18且名字不为tiny所有记录userMode.find(&#123;&quot;$nor&quot;: [&#123;&quot;name&quot;: &quot;tiny&quot;&#125;, &#123;&quot;age&quot;: 18&#125;]&#125;, function (error, docs) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;$nor查询结果：&quot;, docs) &#125;&#125;); exist查询： $exists操作符，可用于判断某些关键字段是否存在来进行条件查询 12345678//查询所有存在name属性的文档userMode.find(&#123;name: &#123;$exists: true&#125;&#125;, function (error, docs) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.error(&quot;exists查询结果：&quot;, docs) &#125;&#125;);]]></content>
      <tags>
        <tag>mongodb mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域]]></title>
    <url>%2F2018%2F11%2F26%2F%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-js%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[作用域 几乎所有的编程语言最基本的功能，储存变量中的值，并且之后对这个值进行访问和修改，这些值存在哪里，我们如何获取他们？这些问题说明我们需要设计一套良好的规则来储存变量，并且之后可以方便地找到这些变量，这些规则我们称作“作用域” javascript 运行原理 javaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度 解析性语言： 边解释边执行 源代码===&gt; 抽象语法树 ===&gt;解析器解析和执行 编译性语言：先编译在执行 源代码===&gt; 抽象语法树 ===》中间表示形式 ===》本地代码 JavaScript语言是解释型语言，为了提高性能，引入了Java虚拟机和C++编译器中的众多技术。现在JavaScript引擎的执行过程大致是： 源代码-→抽象语法树-→字节码-→JIT（just in time 即时编译）-→本地代码（v8没有中间字节码）V8更加直接的将抽象语法树通过JIT技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。 但是在2017年4月底，v8 的 5.9 版本发布了，新增了一个 Ignition 字节码解释器，将默认启动，从此之后将与JSCore有大致相同的流程。做出这一改 变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度 因为之前 v8 选择了直接将 JS 代码编译到机器代码执行，机器码的执行性能已经非常之高，而这次引入字节码则是选择编译 JS 代码到一个中间态的字节码，执行时是解释执行，性能是低于机器代码的。最终的性能测试势必会降低，而不是提高。那么 V8 为什么要做这样一个退步的选择呢？为 V8 引入字节码的动机又是什么呢？笔者总结下来有三条： –（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间 – 提高代码的启动速度 – 对 v8 的代码进行重构，降低 v8 的代码复杂度 故事得从 Chrome 的一个 bug 说起： http://crbug.com/593477 。Bug 的报告人发现，当在 Chrome 51 (canary) 浏览器下加载、退出、重新加载 facebook 多次，并打开 about:tracing 里的各项监控开关，可以发现第一次加载时 v8.CompileScript 花费了 165 ms，再次加载加入 V8.ParseLazy 居然依然花费了 376 ms。按说如果 Facebook 网站的 js 脚本没有变，Chrome 的缓存功能应该缓存了对 js 脚本的解析结果，不该花费这么久。这是为什么呢？这就是之前 v8 将 JS 代码编译成机器码所带来的问题。因为机器码占空间很大，v8 没有办法把 Facebook 的所有 js ,代码编译成机器码缓存下来，因为这样不仅缓存占用的内存、磁盘空间很大，而且退出 Chrome，再打开时序列化、反序列化缓存所花费的时间也很长，时间、空间成本都接受不了。所以 v8 退而求其次，只编译最外层的 js代码，也就是下图这个例子里面绿色的部分。那么内部的代码（如下图中的黄色、红色的部分）是什么时候编译的呢？v8推迟到第一次被调用的时候再编译。这时间上的推移还导致另外一个短板，就是代码必须被解析多次——绿色的代码一次、黄色的代码再解析一次（当 new Person 被调用）、红色的代码再解析一次（当 doWork() 被调用）。因此，如果你的 js 代码的闭包套了 n 层，那么最终他们至少会被 v8 解析 n 次。 Facebook 的网站之所以收到这个设计带来的负面的性能影响，就是因为他们的前段工程流程中最后把各个独立的 module 编译成了一个单独的文件，其中用到了很多闭包 刚才提到了机器码占空间大的一个坏处，就是不能一次性编译全部的代码。机器码占空间大还有另外一个坏处，就是一些只运行一次的代码浪费了宝贵的内存 资源。正如上面 Facebook 中的 __d() 系列函数，他们的作用可能只是注册、初始化各个模块组件，而一旦初始化完成便不会再执行。但由于机器码占空间大，这些只执行一次的代码也会在内存中长期存在、长期占用空间。 而引入字节码之后(进行代码优化)，占空间的问题就可以得到缓解。通过恰当地设计字节码的编码方式，字节码可以做到比机器码紧凑很多。V8 引入Ignition 字节码后，代码的内存占用确实降低了； 预编译 javascript引擎主要负责整个javascript程序编译及执行过程；作用域：引擎的一个好朋友，负责收集和维护所有声明的标识符，组成的一系列查询，并实施一套非常严格的规则，确定当前代码对这些标识符的访问权限； 总的来说：js运行 词法分析 语法分析（AST）,预编译，解析执行 语法分析和预编译发生在解析执行之前； 1.词法分析：将字符组成的字符串分解成（对编程语言来说有意义）的代码块，这些代码块称为词法单元 2.语法分析：这个过程将词法单元流转换成一个由元素逐级嵌套组成的代表了js程序语法的结构的树 预编译分类：全局预编译：脚本代码块script执行前,查找全局变量声明（包括隐式全局变量声明,省略var声明变量名作全局对象的属性,值为undefined函数预编译： 预编译(函数执行前)※ 1.创建AO对象（Active Object） 2.查找函数形参及函数内变量声明，形参名及变量名作为AO对象的属性，值为undefined 3.实参形参相统一，实参值赋给形参 4.查找函数声明，函数名作为AO对象的属性，值为函数引用解析执行：解析执行编译好的机械码（预编译阶段将抽象语法树转为中间字节码通过jit转为机械码） 举例：1234567891011121314&lt;script&gt; var a = 1;// 变量声明 function b(y)&#123;//函数声明 var x = 1; console.log('so easy'); &#125;; var c = function()&#123;//是变量声明而不是函数声明！！ //... &#125; b(100);&lt;/script&gt;&lt;script&gt; var d = 0;&lt;/script&gt; 看看javascript引擎对这段代码做了什么？ 1.页面产生便创建了GO全局对象（Global Object）（也就是大家熟悉的window对象） 2.第一个脚本文件加载 3.脚本加载完毕后，分析语法是否合法 4.开始预编译 5.查找变量声明，作为GO属性，值赋予undefined 6.查找函数声明，作为GO属性，值赋予函数体 伪代码：123456789GO/window = &#123; //页面加载创建GO同时，创建了document、navigator、screen等等属性，此处省略 a: undefined, c: undefined， b: function(y)&#123; var x = 1; console.log('so easy'); &#125;&#125; 执行函数b之前，发生预编译 创建AO活动对象（Active Object） 查找形参和变量声明，值赋予undefined 实参值赋给形参 查找函数声明，值赋予函数体 12345AO = &#123; //创建AO同时，创建了arguments等等属性，此处省略 y: 100, x: undefined&#125; javascript解释执行函数中代码 第一个脚本文件执行完毕，加载第二个脚本文件 第二个脚本文件加载完毕后，进行语法分析 语法分析完毕，开始预编译 重复最开始的预编译步骤… 执行环境及作用域执行环境（有时也称为环境）也被尘称为执行期上下文:执行环境定义了变量和函数并提供了执行他们的环境，每个执行环境都有一个与之关联的变量对象，环境中的变量对象和函数都保存在这个对象中；全局执行环境：宿主环境不同表示的执行对象也不同，游览器中window;函数执行环境：当执行流进入一个函数时，函数环境被推入一个环境栈中，而在这个函数执行之后，栈将其弹出； 销毁：某个执行环境中的代码和方法执行完之后，改环境被销毁，保存在其中所有变量和函数定义也都被随之销毁（全局执行环境直到应用退去才被销毁） 大白话： 当函数执行时，会创建一个执行期上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境，函数每次执行时定义的执行期上下文都是不一样的；当函数执行完毕，他所产生的执行期上下文销毁； 作用域链： 函数内部的[[scope]]属性：在我们创建函数时就会生成这样的一个属性，这个属性保存着这个函数的父作用域的作用域链；在函数执行时，函数会生成一个活动对象（执行期上下文）放到[[scope]]最前端，[[scope]]属性中存在的执行期上下文集合，就是我们常说的作用域链； 当代码在一个环境中执行时，会创建变量（函数）对象的一个作用域链(scope chain);作用域链的用途，是创建的函数保证对执行环境中变量和函数有序的访问； 活动对象：作用域的最前端，是当前执行函数所在的执行环境，将其活动对象（activation object）作为变量的对象；12345678910111213// sort 比较函数function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0 &#125;&#125;compare(5, 10); 后台的每一个执行环境都有一个表示变量的对象—变量对象、全局环境的变量对象始终存在，像compare()，函数这样局部环境变量对象只在函数执行过程中存在。 创建compare()函数的时候，会创建一个预先包含全局变量对象（global|| window）的作用域链，这个对象被保存在函数内部的[[scope]]属性中；( 发生在预编译阶段) 执行compare()函数的时候，会为函数创建一个执行环境，然后通过复制[[scope]]属性中的对象构建起执行环境的作用域链；（发什么在解析执行阶段） 此后又有一个活动对象被创建，被推入执行队列的最前端 垃圾回收机制javascript具有自动回收垃圾机制的，也就是说，执行环境会负责管理代码执行过程中使用的内存，而在c和c++之类的语言中，开发人员一项基本任务是手动的跟踪内存的使用情况，这也是造成许多问题的根源。在编写javascript程序时，开发人员不用在担心内存的使用哪个问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾回收机制很简单：找出那些不在继续使用的变量，然后释放其占用的内存，为此垃圾回收器会按照固定的时间间隔（或者代码执行中预定的收集时间）周期性的执行这一个操作。局部变量的生命周期，局部变量只有在函数执行的过程中存在，在这个过程中，会为局部变量在栈或者堆内存上分配相应的空间，一遍储存他们的值。然后在函数中使用这些变量，直到函数执行结束。此时局部变量没有存在的必要了，因此可以释放他们的内存以供将来使用；全局变量的生命周期直到游览器卸载页面才会结束； 标记清除 这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间； 举例： 12345var a = 3;function b() &#123; var c = 7;&#125;b(); 预编译之后解析执行： 函数执行时启动垃圾回收机制，将c标记为进入环境，执行完之后将其标记为离开环境；这中间，垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量；闭包函数的生命周期还没有结束； 闭包 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的常用方式，就是在函数内部，创建另一个函数；来自===》高级程序设计 12345678function foo() &#123; var a = 2; function bar() &#123; console.log('a'); &#125; bar();&#125;foo(); 上面也可以说是闭包；但是不是很明显，bar中对a的引用是作用域的查找规则； 我查阅你不知道的javascript和高级程序设计总结出自己理解的闭包： 1.函数嵌套函数 2.函数中有对另一个函数作用域中变量的引用 3.原有作用域链不被销毁，垃圾回收机制不能进行回收 123456789function foo() &#123; var a = 2; function b() &#123; console.log('a'); &#125; return b;&#125;var limit = foo();limit(); 当定义foo时将全局执行环境对象复制到了foo函数的[[scope]]属性中；执行foo时创建foo的活动对象放到[[scope]]的最前端定义b函数时，复制foo函数的[[scope]]放到b函数的[[scope]]属性中；正常当foo函数执行完之后，我们常常期望，foo的整个内部作用域被销毁，因为我们知道引擎有垃圾回收器用来释放不在使用的内存空间。但是在我们这个例子中作用域依然存在，执行limit()输出为2；谁在使用这个内部作用域？ 拜b()所声明的位置决定，他拥有富含foo()内部作用域的闭包（引用），使得改作用域一直存活；以供b()在之后任何位置引用，b()依然持有该作用于的引用，这个引用称作闭包；高级程序设计有很好的图；180页； 常见闭包问题：定时器闭包 123456function wait(message) &#123; setTimeout(function timer() &#123; console.log('message') &#125;, 1000)&#125;wait('hello closure'); 将一个内部函数timer函数传递給setTimeout(),timer具有蕴含wait作用域的引用（闭包);wait()执行完之后期作用域没有消失，1秒后执行timer,timer执行完之后销毁执行期上下文；（这里涉及到执行队列，异步相关知识，之后总结）;所以少用setTimeInterval()，他会一直执行，导致作用域链不被释放；闭包有很多应用：在定时器，事件监听器，ajax请求，跨窗口通信，使用回调函数，就是在使用闭包； 循环和闭包12345for(var i=1;i&lt;=5;i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125; 我们期望输出,1,2,3,4,5，但是他输出的是5个6；为什么呢？循环总是先结束的，即使时间间隔为0;循环结束之后全局变量i；变为6；执行异步代码执行timer，创建执行期上下文，引擎根据查找规则找，沿着作用域链进行查找，执行期上下文对象里面没有，向全局作用域查找,此时全局i变为6；输出为6； 怎么能得到预期的结果呢？缺陷：假设循环中的每个迭代在运行时候都会给自己捕获一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中五个函数是在各个迭代中分别定义的，但是他们被封闭在一个共享的全局作用域中，实际上只有一个i；如果我们通过在外层增加一个函数，将timer封装在函数作用域中，通过引用函数执行期上下文中的j(j=i)，不就好了吗？ 12345678for(var i=1;i&lt;=5;i++) &#123; (function(j)&#123; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000) &#125;)(i)&#125;// 输出 1，2，3，4，5 立即执行函数，会为某个迭代生成一个新的作用域，我们可以引用新的作用域的值； 我们使用立即执行函数时每次迭代时候会创建一个新的作用域，换句话说每次迭代都需要一个块级作用域；es6提出块作用域，与之相关的变量声明，let,const； let let关键字可以将《变量》绑定到所在的任意作用域中（通常是{….}内部），换句话说，let为其声明的变量隐试地劫持了所在的块作用域；隐式块作用域,函数不可隐式的劫持块作用域；123456if() &#123; let a = 3;&#125; for() &#123; let a = 3;&#125; 通过打断点，当let显示，或者隐式绑定块作用域时，当执行块中的代码时，会在作用域链的前端加上Block的活动对象这个活动对象里面只包含，在块中let声明的变量，当执行完代码块中的代码时，垃圾回收机制释放Block执行上下文的内存；这也是，在别的作用域中访问不到，let声明的变量的值原因；可以显示的定义块作用域,显示的加上{};当执行函数d时候，会产生执行期上下文图中scope下面的local对象，local里面有let定义的d变量，f变量，如果块作用域中，有var，函数声明的话都提到local中； 如图：当js引擎执行到代码块中时，会在[[scope]]属性的最前端加上Block的作用域（执行期上下文），这个对象中只包含let和const声明的变量； 如图：当代码块中代码执行完之后，活动对象会被垃圾回收器回收； 12345678for(var i=1;i&lt;=5;i++) &#123; &#123; let j = i; setTimeout(function timer() &#123; console.log(j); &#125;, i*1000) &#125;&#125; let将j变量显示的绑定到了块级作用域上，每一次迭代生成新的块级作用域，相当于上面的立即执行函数方法；在全局与函数作用域之间加上一个块级作用域，timer回调函数被Block执行环境所包裹，每一次都取不同的变量j;得到预期的结果；改进：12345for(let i=1;i&lt;=5;i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125; for循环中(){}块级作用域是父子关系；for循环中的let声明，有一个特殊的行为，这个行为指出变量在循环过程中不止声明一次，随后的每个迭代都会使用上一次迭代结束的值初始化这个变量；每次迭代let将i绑定到新的块级作用域上，timer中的i访问Block中的i，得到预期的结果（看不懂断点），使用这种方式避免了全局污染，并且，timer中的代码执行完，将释放掉leti绑定的块级作用域的空间（垃圾回收） 块级作用域和let的关系： 通过let,const将变量绑定到块级作用域； 总结： 1.let 声明的变量，不存在变量提升，比较好控制 2.let 声明的变量，存在暂时性死区，绑定变量于相应块级作用域内、外部相同变量的声明无法修 改作用域内变量 3.let 声明的变量，在相同作用域内，不允许重复声明 4.垃圾收集，如上例子，执行完timer之后，立即释放它的父块级作用域； 还有一些其他的代码模式利用了闭包强大的威力，之后我会用一些篇幅来研究其中最强大的一块：模块； 参考： 你不知道的javascript; 高级程序设计 JS 引擎与字节码的不解之缘: 网址 v8引擎详解: 网址]]></content>
      <tags>
        <tag>闭包 作用域链 javascript编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块话]]></title>
    <url>%2F2018%2F11%2F22%2F%E6%A8%A1%E5%9D%97%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[redux]]></title>
    <url>%2F2018%2F11%2F22%2Fredux%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[regExp]]></title>
    <url>%2F2018%2F11%2F16%2FregExp%2F</url>
    <content type="text"><![CDATA[正则表达式的作用 匹配特殊字符或有特殊匹配原则的字符的最佳选择 转义字符：\ 和特殊字符组合有特殊功能，\n回车； 和级特殊的字符组合如转义字符，能输出转义字符，回车和转义字符都是极特殊字符； 123456var str = &apos;l\nq&apos;;&apos;lnq&apos;str = &apos;l\\nq&apos;;&apos;l\nq&apos; 正则表达式写法 （1）字面量 var regExp = //; /正则表达式主体/修饰符(可选) (2) 创建 RegExp 对象的语法 var reg = new RegExp(pattern, attributes); 参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。 参数 attributes 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。 两者的主要区别： 1.采用直接量语法新建的正则表达式对象在代码编译时就会生成，是平常开发中常用的方式 2.采用构造函数生成的正则对象要在代码运行时生成。 正则表达式的属性和方法： ignoreCase 返回Boolean，表示regExp是否有表示i; global 返回布尔值，表示RegExp对象是否具有标志g multiline 返回布尔值，表示RegExp 对象是否具有标志 m。 lastIndex 一个整数，标识开始下一次匹配的字符位置; source 返回正则表达式的源文本（不包括反斜杠） i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配 正则表达式作用 （1）验证： 用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串； （2）搜索替换： 搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和$ 字符类匹配 […] 查找方括号之间的任何字符 [^…] 查找任何不在方括号之间的字符 [a-z] 查找任何从小写 a 到小写 z 的字符 [A-Z] 查找任何从大写 A 到大写 Z 的字符 [A-z] 查找任何从大写 A 到小写 z 的字符 . 查找单个字符，除了换行和行结束符 \w 查找单词字符，[a-zA-Z0-9_] \W 查找非单词字符，等价于[^a-zA-Z0-9] \s 查找空白字符 \S 查找非空白字符 \d 查找数字，等价于[0-9] \D 查找非数字字符，等价于[^0-9] \b 匹配单词边界 \B 匹配非单词边界 \r 查找回车符 \t 查找制表符 \0 查找 NULL 字符 \n 查找换行符 重复字符匹配： {n,m} 匹配前一项至少n次，但不能超过m次 {n,} 匹配前一项n次或更多次 {n} 匹配前一项n次 n？ 匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0，1} n+ 匹配前一项1次或多次，等价于{1，} n* 匹配前一项0次或多次，等价于{0，} n$ 匹配任何结尾为 n 的字符串 ^n 匹配任何开头为 n 的字符串 ?=n 匹配任何其后紧接指定字符串 n 的字符串 12345var str = &apos;aaaBaaac&apos;;var reg = /(?=[A-Z])/; // 匹配挨着[A-Z]的字符串 用于插入字符串片段;str.split(reg);// [&apos;aaa&apos;, &apos;Baaac&apos;] ?!n 匹配任何其后没有紧接指定字符串 n 的字符串 匹配特定数字 ^[1-9]\d$ 匹配正整数 ^-[1-9]\d$ 匹配负整数 ^-?[0-9]\d$ 匹配整数 ^[1-9]\d|0$ 匹配非负整数（正整数 + 0） ^-[1-9]\d|0$ 匹配非正整数（负整数 + 0） ^[1-9]\d.\d|0.\d[1-9]\d$ 匹配正浮点数 ^-([1-9]\d.\d|0.\d[1-9]\d)$ 匹配负浮点数 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 匹配浮点数 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d.\d|0.\d[1-9]\d*))|0?.0+|0$ 匹配非正浮点数（负浮点数 + 0） 匹配特定字符串： ^[A-Za-z]+$ 匹配由26个英文字母组成的字符串 ^[A-Z]+$ 匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ 匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ 匹配由数字和26个英文字母组成的字符串 ^\w+$ 匹配由数字、26个英文字母或者下划线组成的字符串 正则表达式的属性和方法： test:如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。 12345var reg = /abc/g;var str = &quot;123abc456abc&quot;;reg.test(&apos;b&apos;);// true; exec方法: exec() 方法用于检索字符串中的正则表达式的匹配 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null 全局匹配:exec方法也是匹配字符串中所有满足条件的结果，但是默认只能返回第一次匹配到的结果, 得手动调用； 数组里面得值： 123456var regExp = /\w/g; // 全局匹配var returnValue = regExp.exec(&apos;123&apos;);// [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined] (第一次)// [&quot;2&quot;, index: 1, input: &quot;123&quot;, groups: undefined] (第2次) 子表达式的反向引用： 匹配： &apos;abba&apos;形式的字符串 1234var reg = /([A-z])([A-z])\2\1/;var str = &apos;abba&apos;;reg.test(str);// true; 型如&apos;aabb&apos; 12345var reg = /([A-z])\1([A-z])\2/;var str = &apos;aabb&apos;;reg.test(str);// true; 形如&apos;abab&apos;; 1234var reg = /([A-z])([A-z])\1\2/;var str = &apos;abab&apos;;reg.test(str);// true; 字符串的方法 search方法：方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 返回值： stringObject 中第一个与 regexp 相匹配的子串的起始位置。 注释：如果没有找到任何匹配的子串，则返回 -1。 search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 1234var str = &apos;abca&apos;;str.search(/a/g);// 0 match方法: match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。 字符串对象的match方法与正则对象的exec方法比较类似： 但是如果正则表达式带有g修饰符，那么match方法与exec方法就有差别了: 可以看到match返回了所有成功匹配的结果，但是exec方法只返回了一个 replace方法: replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 参数： | 参数 | 描述 | | :—— | | regexp/substr | 必须, 规定子字符串或者要替换的模式的 RegExp 对象 | | replacement | 必须、；一个字符串值规定了替换文本或者生成替换文本的函数 | 返回值：一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。 字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement可以是子字符串也可以是函数。如果是子字符串那么每个匹配都将由子符串进行替换， 但是replacement中的$字符有特定的含义，$1、$2、…、$99， 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 replacement 为函数的时候; 函数第一个参数为第一次匹配到的字符串，第二个参数为匹配到的第一个子表达式, 第三个参数为第二个子表达式， 如下： 12345678910111213var str = &apos;the-first-name&apos;;var reg = /-(\w)/g;str.replace(reg, (match, $1)=&gt; &#123; // 匹配到几个就执行几次 执行两次 console.log(match, $1); // -f f // -n n // 返回 替换的字符串 return $1.toUpperCase();&#125;);// 返回值 theFirstName 123456789101112var str = &apos;liyingqi&apos;;var returnValue = str.replace(&apos;i&apos;);console.log(returnValue); // &quot;lundefinedyingqi&quot; // &apos;不写第二个参数&apos; 默认由undefined 替换匹配到的字符串；var str = &apos;liyingqi&apos;;var returnValue = str.replace(&apos;f&apos;);console.log(returnValue); // 没匹配到， 返回全部字符串var str = &apos;liyingqi&apos;;var returnValue = str.replace(&apos;i&apos;, &apos;pp&apos;);console.log(returnValue); // &quot;lppyingqi&quot; // substr，匹配子字符串; 只替换第一个子串；// 经典案例： 驼峰转化为中划线 形如： liYingQi ===&gt; li-ying-qi 1234567891011121314151617181920212223242526272829303132333435363738394041424344var reg = /([A-Z])/g;var str = &apos;liYingQi&apos;;// 匹配第一个子表达式var returnValue = str.replace(reg, &apos;-$1&apos;).toLowerCase();console.log(returnValue); // &quot;li-ying-qi&quot;// 封装方法function middleLine(str) &#123; return str.replace(/\B([A-Z])/g, &apos;-$1&apos;).toLowerCase();&#125;middleLine(&apos;liYingQi&apos;); // li-ying-qi;// 严谨一点function middleLine(str) &#123; // 类型判断 var lock; lock = typeof str === &apos;string&apos; &amp;&amp; str ? false : true; if (lock) &#123; return false; &#125; return str.replace(/\B([A-Z])/g, (match)=&gt; &#123; return `-$&#123;match.toLowerCase()&#125;`; &#125;);&#125; // 推荐使用 npm包humps, 有很多方法， 源码 https://github.com/domchristie/humps/blob/master/humps.js参考了一下: humps, 增加扩展性option : separator 分隔符 split 自定义拆分正则； function middleLine (string, option) &#123; var lock; lock = typeof string === &apos;string&apos; &amp;&amp; string ? false : true; if (lock) &#123; return false; &#125; option = option || &#123;&#125;; var separator = option.separator || &apos;-&apos;; var split = option.split || /(?=[A—Z])/; return string.split(split).join(separator).toLowerCase();&#125; (?:) // 不记录子表达式内容； split方法： split(‘字符串的分割正则’,’返回数组的最大成员数’)；返回分割后各部分组成的数组； humps 源码解读 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133;(function(global) &#123; // 转化对象中的name的写法 递归方法 var _processKeys = function(convert, obj, options) &#123; if(!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) &#123; return obj; &#125; var output, i = 0, l = 0; if(_isArray(obj)) &#123; output = []; for(l=obj.length; i&lt;l; i++) &#123; output.push(_processKeys(convert, obj[i], options)); &#125; &#125; else &#123; output = &#123;&#125;; for(var key in obj) &#123; if(Object.prototype.hasOwnProperty.call(obj, key)) &#123; output[convert(key, options)] = _processKeys(convert, obj[key], options); &#125; &#125; &#125; return output; &#125;; // 字符串转换方法 var separateWords = function(string, options) &#123; options = options || &#123;&#125;; var separator = options.separator || &apos;_&apos;; // /(?=[A-Z])/ 紧挨着 大写字母的’‘； var split = options.split || /(?=[A-Z])/; return string.split(split).join(separator); &#125;; // 将形如 \ - _ 改写小驼峰写法 var camelize = function(string) &#123; if (_isNumerical(string)) &#123; return string; &#125; string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) &#123; return chr ? chr.toUpperCase() : &apos;&apos;; &#125;); // 保持第一个字符一直是小写 return string.substr(0, 1).toLowerCase() + string.substr(1); &#125;; // 首字符大写的大驼峰写法 var pascalize = function(string) &#123; var camelized = camelize(string); // 确定第一个字符一直是大写 // 截取第一位变成大写 + 从索引为1一直截取到最后的字符串 return camelized.substr(0, 1).toUpperCase() + camelized.substr(1); &#125;; // 驼峰变为- \ _ decamelize(&apos;liYingQi&apos;); var decamelize = function(string, options) &#123; return separateWords(string, options).toLowerCase(); &#125;; // Utilities // Taken from Underscore.js var toString = Object.prototype.toString; var _isFunction = function(obj) &#123; return typeof(obj) === &apos;function&apos;; &#125;; var _isObject = function(obj) &#123; return obj === Object(obj); &#125;; var _isArray = function(obj) &#123; return toString.call(obj) == &apos;[object Array]&apos;; &#125;; var _isDate = function(obj) &#123; return toString.call(obj) == &apos;[object Date]&apos;; &#125;; var _isRegExp = function(obj) &#123; return toString.call(obj) == &apos;[object RegExp]&apos;; &#125;; var _isBoolean = function(obj) &#123; return toString.call(obj) == &apos;[object Boolean]&apos;; &#125;; // 判断传入对象是数字的最高效率的方法 var _isNumerical = function(obj) &#123; obj = obj - 0; return obj === obj; &#125;; //设置方法 //允许通过回调修改convert函数 var _processor = function(convert, options) &#123; var callback = options &amp;&amp; &apos;process&apos; in options ? options.process : options; if(typeof(callback) !== &apos;function&apos;) &#123; return convert; &#125; return function(string, options) &#123; return callback(string, convert, options); &#125; &#125;; var humps = &#123; camelize: camelize, decamelize: decamelize, pascalize: pascalize, depascalize: decamelize, camelizeKeys: function(object, options) &#123; return _processKeys(_processor(camelize, options), object); &#125;, decamelizeKeys: function(object, options) &#123; return _processKeys(_processor(decamelize, options), object, options); &#125;, pascalizeKeys: function(object, options) &#123; return _processKeys(_processor(pascalize, options), object); &#125;, depascalizeKeys: function () &#123; return this.decamelizeKeys.apply(this, arguments); &#125; &#125;; // 定义导出方式 是AMD, CMD 规范 if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; define(humps); &#125; else if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = humps; &#125; else &#123; global.humps = humps; &#125;&#125;)(this);]]></content>
      <tags>
        <tag>regExp 正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-常见面试题]]></title>
    <url>%2F2018%2F11%2F16%2Fjs-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常见的数组面试题； 数组去重： Es5 12345678910111213141516171819202122232425262728293031function unique(arr) &#123; var newArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) === -1) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;function unique(arr) &#123; var newArr = [], newObj = &#123;&#125;, arrVal, type, objVal; for (var i = 0; i &lt; arr.length; i++) &#123; arrVal = arr[i]; objVal = newObj[arrVal]; type = typeof arrVal; console.log(objVal, arrVal); if (!objVal) &#123; newObj[arrVal] = [type]; newArr.push(arrVal); &#125; else if (objVal.indexOf(type) == -1) &#123; newObj[arrVal] = [type]; newArr.push(arrVal); &#125; &#125; return newArr;&#125; Es6 123[...new Set([1,2,1,1,1])];Array.from(new Set([1,2,1,1,1])) 排序sort sort() 方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串Unicode码点。 语法：arrayObject.sort(sortby)；参数sortby可选。规定排序顺序。必须是函数。 注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 1234567891011121314151617var data = [ &#123;age: 15, name:101&#125;, &#123;age: 19, name: 100&#125;, &#123;age: 15, name: 130&#125;, &#123;age: 15, name: 120&#125;, &#123;age: 19, name: 99&#125;, &#123;age: 19, name: 88&#125; ]; data.sort(function (a, b) &#123; // 年龄相等按照 name排列 if (a.age === b.age) &#123; return a.name - b.name; &#125; return a.age - b.age; &#125;); console.log(data) 打乱数组 1234567891011121314arr.sort(function()&#123; return 0.5 - Math.random() &#125;)var str=arr.join();alert(str);//打乱数组 循环随机位交换法var arr = [1, 2, 3,4,5]for (var i = 0; i &lt; arr.length; i++) &#123; var x = Math.floor(Math.random() * (length - 1)); var y = Math.floor(Math.random() * (length - 1)); var temp = arr[x]; arr[x] = arr[y]; arr[y] = temp;&#125;console.log(arr); 找出重复出现最多次的字母 12345678910111213141516171819202122232425262728293031323334 var str = &apos;abababcccccababab&apos;; var obj = str.split(&apos;&apos;).reduce((initData, ele, index, arr)=&gt; &#123; initData[ele] = initData[ele] ? ++initData[ele] : 1; return initData; &#125;, &#123;&#125;) console.log(obj); // &#123;a: 6, b: 6, c: 5&#125; function FindMaxChar (str) &#123; //长度唯一，返回 if (str.length === 1) &#123; return str; &#125; var obj = &#123;&#125;; //charAt返回字符串的字符 for (var i = 0; i &lt; str.length; i++) &#123; if (!obj[charAt(i)]) &#123; obj[charAt(i)] = 1; &#125; else &#123; obj[charAt(i)] += 1; &#125; &#125; var strValue = &apos;&apos;, maxChar; for ( var k in obj) &#123; //判断哪个字母出现的频率最高，把频率最高的输出出去 if (obj[k] &gt;= strValue ) &#123; maxChar = k; strValue = obj[k] ; &#125; &#125; return maxChar;&#125; 变量交换 实现a, b的交换 12345678function swap(a,b) &#123; var c; c = a; a = b; b = c; return [a,b]&#125;console.log(swap(a, b)); // 生成斐波那契数组的方法 1 1 2 3 5… 1234567891011121314151617181920212223242526272829303132333435 function fn(n) &#123; if (n === 1 || n === 2) &#123; return 1; &#125; return fn(n - 1) + fn(n - 2); &#125; fn(4); var a1=1; var a2=1; var a3=0; for(var i=2;i&lt;=n;i++)&#123;//因为前两个数都是1，所以要从i=2开始，就是前两个数的1+1=2，i的初始值其实是第三个数 a3=a1+a2;//第三个数等于第一个数加上第二个数 a1=a2;//第一个数就变成了之前的第二个数 a2=a3;//第二个数就变成了刚刚的第三个数 &#125; // 斐波那契数列数组function getFibonacci(n) &#123; var fibarr = []; var i = 0; while (i &lt; n) &#123; if (i &lt;= 1) &#123; fibarr.push(i); &#125;else &#123; fibarr.push(fibarr[i - 1] + fibarr[i - 2]); &#125; i++; &#125; return fibarr;&#125;console.log(fabonacci(5)); 递归全排列，打印n个数的全排列， n = 3;则这三个数1，2，3的全排列有： 1 深度克隆 12345678910111213141516171819202122232425262728293031323334353637383940function deepClone(target) &#123; var newContent = Array.isArray(target) ? [] : &#123;&#125;; var copy; for (var prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; copy = target[prop]; // 防止循环引用 if (copy === target) &#123; newContent[prop] = copy; continue; &#125; if (Array.isArray(copy) &amp;&amp; isPlainObject(copy)) &#123; newContent[prop] = deepClone(copy); &#125; else &#123; newContent[prop] = copy; &#125; &#125; &#125; return newContent;&#125;// 判断纯对象 字面量 new Object() 创建的function isPlainObject(obj) &#123; var proto; var Ctor; var hasOwn = &#123;&#125;.hasOwnProperty; if (!obj &amp;&amp; Object.prototype.toString.call(obj) !== &apos;[object Object]&apos;) &#123; return false; &#125; // 获取原型 proto = Object.getPrototypeOf(obj); // Object.create(null) if (!proto) &#123; return true; &#125; // 由全局Object对象构建的对象是普通对象，抛出了自定义构造函数的实例对象 // 实例对象 Ctor = hasOwn.call(proto, &apos;constructor&apos;) &amp;&amp; proto.constructor; return typeof Ctor &amp;&amp; &apos;function&apos; &amp;&amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object);&#125; Object.assign实现 123456789101112131415 Object.assign = function (target, ...source) &#123; if (arguments.length === 1) &#123; return target; &#125; source.forEach((ele,key)=&gt; &#123; for (var prop in ele) &#123; if (ele.hasOwnProperty(prop)) &#123; target[prop] = ele[prop]; &#125; &#125; &#125;); return target; &#125;` jQuery深度克隆 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, // 取第一个参数 如果存在就取，不存在 target = &#123;&#125;; target = arguments[ 0 ] || &#123;&#125;, i = 1, // 参数长度 length = arguments.length, // 是否为深度克隆 deep = false; // Handle a deep copy situation // 第一个参数 为布尔值的时候，将第一个参数的值付给deep; if ( typeof target === &quot;boolean&quot; ) &#123; deep = target; // Skip the boolean and the target // 进行第二个参数 target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== &quot;object&quot; &amp;&amp; !isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed // 如果只传递一个参数则扩展 jquery本身 if ( i === length ) &#123; console.log(this, 777) target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; console.log(name, 8888) src = target[ name ]; copy = options[ name ]; // console.log(copy, target); // Prevent never-ending loop // 防止永无止境的循环 if ( target === copy ) &#123; continue; &#125; // Recurse if we&apos;re merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don&apos;t bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭州旅游攻略]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%9D%AD%E5%B7%9E%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[第一天： 西湖： 苏堤春晓：贯穿西湖南北风景区的林荫大道；全长三公里，苏题栈下车 断桥残雪：断桥位于白堤东段；一说起平湖秋月的白堤到此为而断，称之为断桥；典故：白素贞许仙相会；断桥站下车； 平湖秋月：南宋时平湖秋月并无固定景址，而以泛舟湖上流览秋夜月景为胜。康熙三十八年，圣祖巡幸西湖，御书‘平湖秋月’匾额，从此，景点固定。现如今的平湖秋月观景点位于白堤西端，背倚孤山，面临外湖；有月亮最佳； 三潭印月：三潭印月是西湖十景之一，被誉为“西湖第一胜境”，三潭印月是西湖中最大的岛屿，风景秀丽、景色清幽，尤三潭印明月的景观享誉中外。主要景点“开网亭”“闲放台”“先贤祠”“迎翠轩”“花鸟厅”“我心相印亭”“曲桥”“九狮石”等 花港观鱼：花港观鱼是由花、港、鱼为特色的风景点。西湖十景之一。地处苏堤南段西侧。1964年二期扩建工程告竣后，占地面积达20公顷。全园分为红鱼池、牡丹园、花港、大草坪、密林地五个景区。与雷峰塔、净慈寺隔苏堤相望。 雷峰夕照：雷峰夕照，位于浙江省杭州市西湖湖南、净慈寺前的夕照山上，西湖十景之七，因晚霞镀塔，佛光普照而闻名 [1] 。雷峰塔建于五代（975），是吴越国王钱弘俶为庆祝黄妃得子而建，初名黄妃塔。 曲院风荷：曲院风荷位于西湖西侧，岳飞庙前面。南宋时，此有一座官家酿酒的作坊，取金沙涧的溪水造曲酒，闻名国内。附近的池塘种有菱荷，每当夏日风起，酒香荷香沁人心脾，因名“曲院风荷”。总占地面积12.65万平方米，总建筑面积268000万平米 双峰插云：双峰插云，指的是西湖南北两高峰奇红异多变的云景。南高峰在烟霞岭旁，北高峰在灵隐寺后，两峰之间层峦叠嶂，重谷回合，绵延二十余里，介从远处看去，则双峰对峙，近若几尺，兀突争雄，秀出群峰 孤山：主要景点有：放鹤亭、林和靖墓、西泠印社，玛瑙坡、一眼泉水、文澜阁、中山公园、清行宫、敬一书院、秋瑾墓、六一泉、苏曼殊墓园、半壁亭等；有诗云：孤山寺北贾亭西，水面初平云脚低；位置：白堤终点； 杨公提：西湖杨公堤位于西湖以西，堤上有六桥，自北向南名为：环璧、流金、卧龙、隐秀、景行、浚源。与东面的苏堤六桥前后呼应，合称为“西湖十二桥”。其中隐秀桥、景行桥可供游船通行。 钱江新城：每周的二五六晚上七点半和八点半各有一场灯光秀； 西溪国家湿地公园： 徒步，门票80；]]></content>
      <tags>
        <tag>浙江 杭州 旅游攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组方法总结]]></title>
    <url>%2F2018%2F11%2F09%2FArray-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组定义 javascript基础数据类型为： Number, String, Boolean, null, undefined, Object, Symbol;今天要总结的是：Array类型 javascript语言与其他语言不同的是，数组的每一项都可以保存任何类型的数据，数组大小可以动态调整； 创建数组方式构造函数创建 123let array = new Array(); // 创建空数组let colors = new Array(20); // length 值为20let names = new Array(&apos;liyingqi&apos;); // 创建一项值为liyingqi 字面量表示法 123let array = []; // 推荐这么用let colors = [2, 3,]; // 不要这样 IE8及更早版本 显示3项， 其他2项 每一项被undefined填充let array = [,,,,,]; // 不要这样 IE8及更早版本 显示6项 其他5项 每一项被undefined填充 练习一下 1234567let arr = [1, 2, undefined, null, &#123;x:1&#125;,f unction()&#123;&#125;];arr.length = 7; arr[6] = undefined;arr.length = 2;arr[2] = undefined; 检测数组 var arr = [1, 2]; 1: arr instanceof Array 123456if (arr instanceof Array) &#123; // 对数组执行某些操作&#125;if (arr.constructor === Array) &#123; // 对数组执行某些操作&#125; 缺点：不准确； 场景： 用iframe里面的方法来判断iframe外的类型是否为数组；因为 Array是挂在window上的； 2: Object.prototype.toString.call(arr); 123if (Object.prototype.toString.call(arr) === &apos;[object Array]&apos;) &#123; // 对数组执行某些操作&#125; call改变this指向当前数组，所以任何场景都可以使用 3: es5新增， Array.isArray(); // 返回值Boolean 12Array.isArray([]);// true 转换方法123[1,2,3].toString() // &apos;1,2,3&apos;[1,2,3].valueOf() // [1,2,3]alert([1,2,3]) //&apos;1,2,3&apos; 默认调用toString() 数组的方法 方法 是否改变原数组 数组返回值 作用 push Y 数组长度 数组末尾入栈 pop Y 原数组最后一项 数组末尾出栈 shift Y 原数组第一项 数组前出栈 unshift Y 数组长度 数组前入栈 reverse Y 反序后的新数组 将数组反序 sort Y 排序后的数组 数组排序 splice Y 删除的数组 数组拼接 join N 字符串 将数组转化为字符串 concat N 合并后的数组 数组拼接 isArray N true或false 数组判断 filter N 符合规则的数组 过滤数组 forEach N 处理后的数组 遍历数组 map N 处理后的数组 数组映射 some N true或false 数组判断 every N true或false 数组判断 some N true或false 数组判断 indexOf N 数组下标或者是-1 数组下标 lastIndexOf N 数组下标或者是-1 数组下标 reduce N 数组下标或者是-1 数组下标 reduceRight N 数组下标或者是-1 数组下标 数组方法push unshift 返回数组长度 pop shift 返回移除的项 堆栈概念 堆，栈：堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。 栈：（stack）又名堆栈，其限制是允许在表的一端进行插入和删除运算，这一端称为栈顶，相对的把另一端称为栈底。 栈就是一个桶，后放进去的先拿出来，（先进后出） ①堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。 ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来。（后进先出） ③队列只能在队头做删除操作,在队尾做插入操作.而栈只能在栈顶做插入和删除操作。（先进先出） javascript 数组，具体来说，数组可以表现的和栈一样，栈是LIFO(last-in-first-out)先进后出， 只需在栈顶插入和移除数据，队列(FIFO)（first-in-first-out）先进先出 用数组实现栈方法 （push, pop）只能在栈顶操作1234567var colors = new Array();var count = colors.push(&apos;red&apos;, &apos;blue&apos;); // 入栈两项ount = colors.push(&apos;black&apos;); // 栈顶插入一项console.log(count); // 3var item = colors.pop(); // 取最后一项 队列方法（push， shift）FIFO 1234567var colors = new Array();var count = colors.push(&apos;red&apos;, &apos;blue&apos;); // 入栈两项var count = colors.push(&apos;black&apos;); // 插入另一项console.log(count); // 3count = colors.shift(&apos;red&apos;, &apos;blue&apos;);console.log(count); // 取得第一项 扩展：用两个栈实现队列 s1是入栈的，s2是出栈的。 入队列：直接压入s1即可 出队列：如果s2不为空，把s2中的栈顶元素直接弹出；否则，把s1的所有元素全部弹出压入s2中，再弹出s2的栈顶元素 换一种思维就是只用push,pop方法实现队列功能，用两个数组实现队列功能，只能用pop,push（soeasy） 操作方法concat方法这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新创建的数组。在没有给concat传参数的情况下，他只是复制当前数组并且返回新副本，如果传递对个数组，这个方法会将数组中的每一项添加到副本中，（对于数组来说只是浅拷贝），如果不是数组这些值只是简单的添加到副本末尾； 1234var colors = [1, 2, 3];var result = colors.concat(1, [6, 7], &#123;name: &quot;value&quot;&#125;);console.log(result); // [1, 2, 3, 1, 6, 7, &#123;name: &quot;value&quot;&#125;]console.log(colors); // [1, 2, 3]; slice 截取数组他能够基于当前数组中的一个，或者多个项创建一个新数组。slice() 方法可以接受一个或者两个参数，返回项的起始和结束位置，在只有一个参数的情况下，返回从该参数指定位置开始，到当前数组末尾的所有项。如果有两个参数，该方法返回起始位置和结束位置之间的所有项，但是不包括结束位置项；slice()方法不会影响原数组； 12345678var colors = [&apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;];var colors2 = colors.slice(1);var colors3 = colors.slice(1, 3);var colors4 = colors.slice(1, -1);console.log(colors2); // [&quot;w&quot;, &quot;e&quot;, &quot;r&quot;]console.log(colors3); // [&quot;w&quot;, &quot;e&quot;]console.log(colors4); // [&quot;w&quot;, &quot;e&quot;] 注意: 如果slice()方法的参数中有一个为负数,则用数组的长度加上该数来确定相应位置，在一个包含4项的数组上调用slice(-3, -1);与调用slice(1, 3)得到的结果相同如colors3,如果结束位置小于起始位置则返回一个空数组； splice 数组拼接，改变原数组删除：可以删除任意数量的项，只需要指定两个参数：要删除第一项的位置和要删除的项数，例如：splice(0, 2);删除数组中的前两项； 插入：可以向指定位置插入任意数量的项，需要3个参数：起始位置，要删除的项数（0），要插入的项，若果要传多个项，可以传入第4，5，6.。。任意多各项， 替换：在插入的基础上，第二个参数不为0,就为替换】； 返回值：splice()方法始终会返回一个数组，该数组包含从原始数组中删除的项（如果没有删除任何项，则返回空数组） 12345678var colors = [&quot;q&quot;, &quot;w&quot;, &quot;e&quot;, &quot;r&quot;];var removed = colors.splice(0, 1);console.log(colors); // [&quot;w&quot;, &quot;e&quot;, &quot;r&quot;]console.log(removed); // [&quot;q&quot;] 返回删除的项removed = colors.splice(1, 0, &apos;liyingqi&apos;);console.log(colors); // [&apos;w&apos;,&apos;liyingqi&apos;, &apos;e&apos;, &apos;r&apos;] // 删除项为0， 在索引前面插入console.log(removed); // 返回空数组 位置方法es5为数组实例添加了两个位置方法：indexOf 和 lastIndexOf() 这两个方法都接受两个参数：要查找的项和查找起点位置的索引；两个方法都可以接受可选的第二个参数 区别在于：indexOf()会从该参数的指定位置向后搜索，lastIndexOf()会从改参数指定位置向前搜索； 返回值：返回要查找的项在数组中的位置，或者在没有找到的情况下，返回-1；要查找的项必须严格相等； 123456789101112var arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];var index = arr.indexOf(4);var lastIndex = arr.lastIndexOf(4);console.log(index); // 3console.log(lastIndex); // 5index = arr.indexOf(4, 4);lastIndex = arr.lastIndexOf(4, 4);console.log(index); // 5 从索引位置向后搜索console.log(lastIndex); // 3 从索引位置向前搜索 归并方法 es5 新增两个归并数组的方法：reduce()和reduceRight(),这两个方法都会迭代数组的所有项。然后构建一个最终返回的值。其中reduce()方法是从数组的第一项开始的遍历到最后， reduceRight()从数组最后一项开始，向前遍历到第一项； arr.reduce(callback,[initialValue]) callback （执行数组中每个值的函数，包含四个参数） previousValue （第一项的值或者上一次叠加的结果值，或者是提供的初始值（initialValue）） currentValue （数组中当前被处理的元素） index （当前元素在数组中的索引） array （数组本身） initialValue （作为第一次调用 callback 的第一个参数，可以控制返回值的格式） reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右），最终计算为一个值。 12345678910111213var arr = [1, 2, 3, 4, 5];sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); //输出的是第一项的值或上一次叠加的结果，正在被处理的元素，正在被处理的元素的索引值 return prev + cur;&#125;)console.log(arr, sum); //输入数组本身和最后的结果// 结果1 2 1 3 3 26 4 310 5 4[1, 2, 3, 4, 5] 15 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;，10); // 结果：35，变成了初始值和数组的和 reduce() 可以作为一个高阶函数，用于函数的 compose。 什么是compose：javascript函数式编程中另外一个很重要的函数compose，compose函数的作用就是组合函数的，将函数串联起来执行，将多个函数组合起来，一个函数的输出结果是另一个函数的输入参数，一旦第一个函数开始执行，就会像多米诺骨牌一样推导执行了。 redux compose源码 123456789101112131415161718192021function compose() &#123; for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key &lt; _len; _key++) &#123; funcs[_key] = arguments[_key]; &#125; if (funcs.length === 0) &#123; return function (arg) &#123; return arg; &#125;; &#125; if (funcs.length === 1) &#123; return funcs[0]; &#125; console.log(arguments); return funcs.reduce(function (a, b) &#123; return function () &#123; return a(b.apply(void 0, arguments)); &#125;; &#125;);&#125; lodash的思路，用迭代实现的，我就把它的源代码贴过来看一下 1234567891011121314151617181920var flow = function(funcs) &#123; var length = funcs.length var index = length while (index--) &#123; if (typeof funcs[index] !== &apos;function&apos;) &#123; throw new TypeError(&apos;Expected a function&apos;); &#125; &#125; return function(...args) &#123; var index = 0 var result = length ? funcs[index].apply(this, args) : args[0] while (++index &lt; length) &#123; result = funcs[index].call(this, result) &#125; return result &#125;&#125;var flowRight = function(funcs) &#123; return flow(funcs.reverse())&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数组定义 数组方法 堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由实现方式及页面跳转]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[a标签的target属性 (1). 默认_self属性在当前框架，或者游览器中打开窗口 (2). 有_blank新的游览器窗口中打开，不可window.history.back() || go(n), forward(); 相当于window.location.reload(); (3). 有_top，场景当出现框架套框架的时候，在底层框架调用_top会导致在整个游览器窗口中打开被链接文档； (4). 有_parent，场景如上，在父框架中打开被链接文档。 (5). 场景：当搜索职位，web前端简历时，在搜索结果页出现一系列的列表，想要点击每一个列表进入简历详情页，并且这些简历详情页只展示在一个新增窗口上; 123456 &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;index1.html&quot; target=&quot;view_window&quot;&gt;Chapter 0&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index2.html&quot; target=&quot;view_window&quot;&gt;Chapter 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index3.html&quot; target=&quot;view_window&quot;&gt;Chapter 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index4.html&quot; target=&quot;view_window&quot;&gt;Chapter 3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 当用户第一次选择内容列表中的某个链接时，浏览器将打开一个新的窗口，将它标记为 &quot;view_window&quot;，然后在其中显示希望显示的文档内容。如果用户从这个内容列表中选择另一个链接，且这个 &quot;view_window&quot; 仍处于打开状态，浏览器就会再次将选定的文档载入那个窗口，取代刚才的那些文档。 (6). 在框架中打开窗口 不用打开一个完整的浏览器窗口，使用 target 更通常的方法是在一个 显示中将超链接内容定向到一个或者多个框架中。可以将这个内容列表放入一个带有两个框架的文档的其中一个框架中，并用这个相邻的框架来显示选定的文档： w3c, 实例结果页就是用这种思想 // 对框架不了解的同学可以，去框架模块看一下(无body), 例子 https://github.com/lyqbetter/blog-demo.git 里面的demo1; javascript 跳转页面window.location.href = url; 在当前窗口跳转页面 window.reload(); //重新刷新页面 window.open(url); // 在新窗口打开网站 前端路由实现方式 提起路由先说一下window.history这个对象吧： 浏览器(窗口 画重点)有一个history对象，用来保存浏览历史 Window.history是一个只读属性，用来获取History 对象的引用，History 对象提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口。 history: 返回值 scrollRestoration： auto; history.scrollRestoration。它提供两个值，auto，作为它的默认值，可以像你所见的大多数情况一样工作，另一个manual，意味着作为一个开发者你拥有了自主掌控任何所需的scroll改变，当用户循环往复于app的history中。如果需要，你可以跟踪scroll的位置轨迹 length: Internet Explorer和Opera从0开始，而Firefox、Chrome和Safari从1开始。 属性声明了浏览器历史列表中的元素数量; state: 状态对象 1234window.history.back(); // 当前窗口游览器回话记录回退window.history.forward(); // 前进window.history.go(n); // n可正可负， 负回退，正前进//如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是默默的失败 路由就是指随着浏览器地址栏的变化，展示给用户的页面也不相同。传统的网页根据用户访问的不同的地址，浏览器从服务器获取对应页面的内容展示给用户。这样造成服务器压力比较大，而且用户访问速度也比较慢。在这种场景下，出现了单页应用。单页应用，就是只有一个页面，用户访问一个网址，服务器返回的页面始终只有一个，不管用户改变了浏览器地址栏的内容或者在页面内发生了跳转，服务器不会重新返回新的页面，而是通过相应的js操作来实现页面的更改。而地址栏内容的改变，显示不同的页面，实现的手段就是前端路由 第一种 HTML5 History两个新增的API：history.pushState 和 history.replaceState，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。 history.pushState方法由于添加会话历史，接受三个参数，依次为： state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。 title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。 url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。(为空当前url) history.replaceState() history.replaceState方法的参数与pushState方法一模一样，区别是它修改浏览历史中当前纪录。 popstate 事件 每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。 需要注意的是，仅仅调用pushState方法或replaceState方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用JavaScript调用back、forward、go方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。 123window.addEventListener(&apos;popstate&apos;, (e)=&gt; &#123; console.log(e);&#125;, false); 第二种Hash就是url 中看到 # ,我们需要一个根据监听哈希变化触发的事件( hashchange) 事件。我们用 window.location.hash 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。 可以为hash的改变添加监听事件： 123window.addEventListener(&apos;hashchange&apos;, (e)=&gt; &#123; console.log(e);&#125;, false); 总结 优点： 从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。 前端路由的优点有很多，比如页面持久性，像大部分音乐网站，你都可以在播放歌曲的同时，跳转到别的页面而音乐没有中断，再比如前后端彻底分离。 开发一个前端路由，主要考虑到页面的可插拔、页面的生命周期、内存管理等。 缺点：使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存 单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置;(scrollRestoration兼容性不好)；]]></content>
      <tags>
        <tag>路由 跳转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端click延迟及zepto的穿透现象]]></title>
    <url>%2F2018%2F10%2F05%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFclick%E5%BB%B6%E8%BF%9F%E5%8F%8Azepto%E7%9A%84%E7%A9%BF%E9%80%8F%E7%8E%B0%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[穿透现象与click的延迟解决方法是分不开的，若要了解穿透现象，需要先了解click延迟的解决原理。 移动端click事件300ms的延迟现象的原因：在最早iphone的safar浏览器中，为了实现触屏中双击放大效果，当用户点击屏幕时后会判断在300ms内是否有第二次点击，如果有，就理解成双击，若没有就是单击, 就会触发click事件. 当你点击移动设备的屏幕时, 可以分解成多个事件，顺序依次为：touchstart — touchmove — touchend — click, 这些事件是按顺序依次触发的 12345678910111213var oLi = document.getElementsByTagName(&apos;li&apos;)[0];oLi.addEventListener(&apos;click&apos;, ()=&gt; &#123; console.log(&apos;click&apos;);&#125;);oLi.addEventListener(&apos;touchend&apos;, ()=&gt; &#123; console.log(&apos;touchend&apos;);&#125;);oLi.addEventListener(&apos;touchmove&apos;, ()=&gt; &#123; console.log(&apos;touchmove按下鼠标，移动，触发&apos;);&#125;);oLi.addEventListener(&apos;touchstart&apos;, ()=&gt; &#123; console.log(&apos;touchstart&apos;);&#125;); 控制台输出： 12345678touchstarttouchendclick。。。。touchstarttouchmove按下鼠标，移动，触发touchend(没有click) 解决延迟的思路：touchstart touchend是没有延迟的，可以在touchend时触发用户想要在click时触发的事件. zepto 解决click延迟的原理：自定义tap事件，当用户点击元素时，touchend事件先发生, 当touchend事件冒泡到document时触发目标元素绑定的tap事件, 12345678910var oLi = document.getElementsByTagName(&apos;li&apos;)[0];document.addEventListener(&apos;touchend&apos;, function (e) &#123; // 生成事件 var tap = new Event(&apos;tap&apos;); // 触发事件 e.target.dispatchEvent(tap);&#125;);oLi.addEventListener(&apos;tap&apos;, function () &#123; // 处理点击事件&#125;); zepto中的点击穿透问题zepto中的 tap 通过兼听绑定在 document 上的 touch 事件来完成 tap 事件的模拟的，是通过事件冒泡实现的。在点击完成时（touchstart / touchend）的 tap 事件需要冒泡到 document 上才会触发。而在冒泡到 document 之前，手指接触和离开屏幕（touchstart / touchend）是会触发 click 事件的。 因为 click 事件有延迟（大概是300ms，为了实现safari的双击事件的设计），所以在执行完 tap 事件之后，弹出层立马就隐藏了，此时 click 事件还在延迟的 300ms 之中。当 300ms 到来的时候，click 到的其实是隐藏元素下方的元素。 如果正下方的元素有绑定 click 事件，此时便会触发，如果没有绑定 click 事件的话就当没发生。如果正下方的是 input 输入框（或是 select / radio / checkbox），点击默认 focus 而弹出输入键盘，也就出现了上面的“点透”现象。 穿透的解决办法 由于 click 事件的滞后性，在这段时间内原来点击的元素消失了，于是便“穿透”了。因此我们顺着这个思路就想到，可以给元素的消失做一个fade效果，类似jQuery里的fadeOut，并设置动画duration大于300ms，这样当延迟的 click 触发时，就不会“穿透”到下方的元素了。 同样的道理，不用延时动画，我们还可以动态地在触摸位置生成一个透明的元素，这样当上层元素消失而延迟的click来到时，它点击到的是那个透明的元素，也不会“穿透”到底下。在一定的timeout后再将生成的透明元素移 pointer-events是CSS3中的属性，它有很多取值，有用的主要是auto和none，其他属性值为SVG服务 12 auto 效果和没有定义 pointer-events 属性相同，鼠标不会穿透当前层。none 元素不再是鼠标事件的目标，鼠标不再监听当前层而去监听下面的层中的元素。但是如果它的子元素设置了pointer-events为其它值，比如auto，鼠标还是会监听这个子元素的。 fastclick使用fastclick库，其实现思路是，取消 click 事件（参看源码 164-173 行），用 touchend 模拟快速点击行为（参看源码 521-610 行）。 1FastClick.attach(document.body); 移动端兼容问题研究javascript事件机制详解（涉及移动兼容）;]]></content>
      <tags>
        <tag>移动端点击事件 延迟 zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOCTYPE 兼容模式和标准模式]]></title>
    <url>%2F2018%2F09%2F23%2FDOCTYPE-%E5%85%BC%E5%AE%B9%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式(quirks mode)。 游览器解析模式 Standards(标准)模式：遵循最新标准。 Quirks（怪癖/兼容）模式：帮助处理所有奇怪的渲染和非浏览器兼容及不符合标准的网页。 Almost Standards（近似标准）模式：针对标准的某个老版本设计的网页。 触发兼容模式 浏览器会根据 DOCTYPE 声明进入正确的呈现模式，但有时候它也并不那么听话，以下情况会触发兼容模式： 未指定URL或者指定的是一个相对的路径（而不是完全限定的Internet地址），大多数浏览器会进入兼容模式而不管当初声明的是什么模式 没有使用或格式错误的DOCTYPE。浏览器如果不能识别一个错误的DOCTYPE，那么也会强制进入兼容模式，建议直接复制拷贝DOCTYPE声明而不是亲自输入。 过渡型的DOCTYPE不同浏览器在处理过渡型DOCTYPE时是有差异的。有可能进入标准模式，也有可能进入兼容模式。 DOCTYPE声明告诉类似的代码校验器或者浏览器应该按照什么规则集解析文档，这些“规则”就是W3C发表的文档类型定义（DTD）中包含的规则文档类型定义（DTD）DTD中包含了一系列标记、属性，用于标记Web文档中能出现哪些元素和元素之间的包含关系。如果没有指定有效的DOCTYPE声明，浏览器可能会使用内置的默认DTD。你也可以自定义DTD，但一般不推荐这样。常见的DOCTYPE声明如下12345678910111213141516171819202122&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;HTML 4.01 Transitional：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;HTML 4.01 Frameset：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;XHTML 1.0 Strict：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;XHTML 1.0 Transitional：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;XHTML 1.0 Frameset：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;XHTML 1.1：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;XHTML 1.1 plus MathML plus SVG：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN&quot; &quot;http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd&quot;&gt; 组成部分12语法：&lt;!DOCTYPE 根元素 可用性 &quot;注册//组织//类型 标签 定义//语言&quot; &quot;URL&quot;&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 根元素指定 DTD 中声明的顶级元素类型，这与声明的 SGML 文档类型相对应，默认HTML 。 可用性指定正式公开标识符(FPI)是可公开访问的对象还是系统资源。 默认 PUBLIC 可公开访问的对象。 SYSTEM 系统资源，如本地文件或 URL。 注册指定组织是否由国际标准化组织(ISO)注册。默认 + ，组织名称已注册。 - 组织名称未注册，Internet 工程任务组(IETF)和万维网协会(W3C)并非注册的 ISO 组织。 组织指定表明负责由 !DOCTYPE 声明引用的 DTD 的创建和维护的团体或组织的名称，即 OwnderID。 IETF 或 W3C。 类型指定公开文本类，即所引用的对象类型。默认 DTD。 标签指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号。默认 HTML 。 定义指定文档类型定义。 Frameset 框架集文档。 Strict 排除所有 W3C 专家希望逐步淘汰的代表性属性和元素，因为样式表已经很完善了。Transitional 包含除 frameSet 元素的全部内容。 语言指定公开文本语言，即用于创建所引用对象的自然语言编码系统。该语言定义已编写为 ISO 639 语言代码(大写两个字母)。 默认 EN。 URL指定所引用对象的位置。 怪异Quirks模式是什么，它和标准Standards模式有什么区别？从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。 在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？ 在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。 区别：总体会有布局、样式解析和脚本执行三个方面的区别。 盒模型 ：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。 设置行内元素的高宽 ：在Standards模式下，给等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。 设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。]]></content>
      <tags>
        <tag>ie 兼容模式 标准模式 盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frameset框架]]></title>
    <url>%2F2018%2F09%2F11%2Fframeset%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[HTML iframe 和 frameset 的区别 iframe 和 frameset 都用于html页面的框架布局。 (1). iframe标签：iframe 是个内联框架，是在页面里生成个内部框架。 (2). frameset 标签：frameset 定义一个框架集，包含多个子框架，每个框架都有独立的文档。 iframe 标签 iframe 是个内联框架，是在页面里生成个内部框架。 frameborder {int}：是否显示框架的边框； src {URL}：指定一个资源(如网页、图片)的uri； scrolling {boolean}：是否显示框架的滚动条； width {int}：定义iframe的宽度； height {int}：定义iframe的高度； 应用场景： 重复嵌套页面，一个页面需要重复利用 frameset 标签 frameset 定义一个框架集，包含多个框架，每个框架都有独立的文档。 123456789101112// 没有body 注意， 有的话不渲染框架&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; &lt;frameset &gt; &lt;frame src=a.htm /&gt; &lt;frame src=b.htm /&gt; &lt;noframes&gt;&lt;/noframes&gt; &lt;/frameset&gt;&lt;/html&gt; ：子框架 ：浏览器不支持此框架的时，显示的内容。 frameset属性： rows ：表示子框架按行的样式布局。以2个子框架为例：rows=”30%,“ ，表示第一个框架占整个页面30%的高度，第二个占剩下的； cols ：表示子框架按列的样式布局。以2个子框架为例：cols=”30%,“ ，表示第一个框架占整个页面30%的长度，第二个占剩下的； noresize: “noresize”表示不调整子框架的范围。 frame 属性： src ：指向一个资源(如页面、图片等)的URI； name ：指定框架的名称，以便进行框架间的操作。 参照示例代码，frm1更改frm2的子集指向的页面：window.parent.frames[“frm2”].location.href = ‘b.htm’ 应用场景：1 后台页面的管理，左边显示 菜单，右边框架 显示详细页面。批量游览简历 https://lpt.liepin.com 本文参考 https://www.cnblogs.com/polk6/archive/2013/05/24/3097430.html]]></content>
      <tags>
        <tag>frameset iframe frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F08%2Fhexo%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 图片转 base64 url]]></content>
  </entry>
  <entry>
    <title><![CDATA[长列表性能优化]]></title>
    <url>%2F2018%2F07%2F02%2F%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端的业务开发中会遇到一些无法使用分页方式来加载的列表，我们一般把这种列表叫做长列表。在本篇文章中，我们把长列表定义成数据长度大于 1000 条，并且不能使用分页的形式来展示的列表。 研究的意义从哪几方面研究 完整渲染的长列表是否有优化的可能？优化的极限在什么位置？ 如果使用非完整的渲染长列表，有哪些方案以及具体的实现思路。 完整渲染长列表如果长列表不去做任何优化，一次完整渲染出来，到底需要多长时间呢？那么首先要先了解创建所有的 HTMLElement 并添加到 Document 中的时间消耗，因为业务中会混杂一些其他的代码，你的业务的性能不会比这个时间快。对浏览器创建元素的性能有大概的了解，才能知道长列表的优化极限在哪里。 我们可以写一个简单的方法来测试这个性能： 12345678910111213var createElements = function(count) &#123; var start = new Date(); for (var i = 0; i &lt; count; i++) &#123; var element = document.createElement(&apos;div&apos;); element.appendChild(document.createTextNode(&apos;&apos; + i)); document.body.appendChild(element); &#125; setTimeout(function() &#123; alert(new Date() - start); &#125;, 0);&#125;; DOM 的操作会引起浏览器的 重排重绘（详情请见重排重绘），如果浏览器的 reflow 执行的时间远大于代码执行时间，会造成你时间计算完成之后，浏览器仍然在卡顿。统计的时间应该是从『开始创建元素』到『可以进行响应』的时间，所以一个合理的做法是把计算放在 setTimeout(function() {}, 0) 中。setTimeout() 中的 callback 会被推迟到浏览器主线程 reflow 结束后才执行，这个时间和 Chrome Devtools 下的 Profile 的时间基本吻合，可以信任这个时间作为渲染时间 当然，上面写法很low, 一般人写不出来 。。。。 ####尝试使用不同的 DOM API有两种方法 createDocumentFragment 文档碎片 innerHTML 字符串模板 使用 DocumentFragment 的方法如下 在线编写demo： 123456789101112131415function createElements(count) &#123; const start = new Date(); let fragment = document.createDocumentFragment(); while(count--) &#123; let ele = document.createElement(&apos;div&apos;); ele.appendChild(document.createNoteText(&apos;&apos; + count)); fragment.appendChild(ele); &#125; document.body.appendChild(fragment); setTimeout(()=&gt; &#123; alert(new Date() - start); &#125;, 0)&#125;createElements(1000); 使用 innerHTML 的方法如下 在线编写demo： 12345678910111213var createElementsWithHTML = function(count) &#123; var start = new Date(); var str = &apos;&apos;; for (var i = 0; i &lt; count; i++) &#123; str = &apos;&lt;div&gt;&apos; + i + &apos;&lt;/div&gt;&apos;; &#125; var element = document.createElement(&apos;div&apos;); element.innerHTML = str; document.body.appendChild(element); setTimeout(function() &#123; alert(new Date() - start); &#125;, 0);&#125;; 数据统计 测试代码的计算的时间每次执行都会有一些误差，表格中的数据使用的是进行 10 次测试的平均值： 非渲染长列表 从上面的测试结果中可以看到，创建 10000 个节点就需要 500ms+，实际业务中的列表每个节点都需要 20 个左右的节点。那么，500ms 也仅能渲染 500 个左右的列表项。 所以完整渲染的长列表基本上很难达到业务上的要求的，非完整渲染的长列表一般有两种方式： 懒渲染：这个就是常见的无限滚动的，每次只渲染一部分（比如 10 条），等剩余部分滚动到可见区域，就再渲染另一部分。 可视区域渲染：只渲染可见部分，不可见部分不渲染。 懒渲染 懒渲染就是大家平常说的无限滚动，指的就是在滚动到页面底部的时候，再去加载剩余的数据。这是一种前后端共同优化的方式，后端一次加载比较少的数据可以节省流量，前端首次渲染更少的数据速度会更快。这种优化要求产品方必须接受这种形式的列表，否则就无法使用这种方式优化。 实现的思路非常简单：监听父元素的 scroll 事件（一般是 window），通过父元素的 scrollTop 判断是否到了页面是否到了页面底部，如果到了页面底部，就加载更多的数据。 可视区域渲染 可视区域渲染指的是只渲染可视区域的列表项，非可见区域的完全不渲染，在滚动条滚动时动态更新列表项。可视区域渲染适合下面这种场景： 每个数据的展现形式的高度需要一致（非必须，但是最小高度需要确定）。 产品设计上，一次需要加载的数据量比较大「1000条以上」。 产品设计上，滚动条需要挂载在一个固定高度的区域（在 window 上也可以，但是需要整个区域都只显示这个列表）。 本文使用 Vue 实现了一个例子来说明这种类型的列表该如何实现，这个例子做了以下三个设定： 列表的高度为 400px。 列表中的每个元素的高度是 30px。 一次加载 10000 条数据。 点击此处看demo]]></content>
      <tags>
        <tag>web优化 长列表</tag>
      </tags>
  </entry>
</search>
